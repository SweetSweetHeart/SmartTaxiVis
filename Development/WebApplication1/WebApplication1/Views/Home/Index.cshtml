@model IEnumerable<WebApplication1.Models.green_16_dec>

@{
    ViewBag.Title = "Home Page";
}
<div>

    @Scripts.Render("~/bundles/d3")
    <div id="slider" class="flat-slider">
    </div>
    <input type="text" id="amount" readonly style="border:0; color:#f6931f; font-weight:bold;">
    <button id="PU">By Pickup</button>
    <button id="DO">By Dropoff</button>
    <div id="diagram"></div>
    <script>
        var width = 900,
            height = 900,
            outerRadius = Math.min(width, height) / 2 - 50,
            innerRadius = outerRadius - 18;

        //create number formatting functions
        var formatPercent = d3.format("%");
        var numberWithCommas = d3.format("0,f");

        //create the arc path data generator for the groups
        var arc = d3.svg.arc()
            .innerRadius(innerRadius)
            .outerRadius(outerRadius);

        //create the chord path data generator for the chords
        var path = d3.svg.chord()
            .radius(innerRadius);

        //define the default chord layout parameters
        //within a function that returns a new layout object;
        //that way, you can create multiple chord layouts
        //that are the same except for the data.
        function getDefaultLayout() {
            return d3.layout.chord()
                .padding(0.03)
                .sortSubgroups(d3.descending)
                .sortChords(d3.ascending);
        }
        var last_layout; //store layout between updates

        /*** Initialize the visualization ***/
        var g = d3.select("#diagram").append("svg")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("id", "circle")
            .attr("transform",
            "translate(" + width / 2 + "," + height / 2 + ")");


        g.append("circle")
            .attr("r", outerRadius);



        jQuery.each(taxizones, function (i, val) {
            val.color = '#' + Math.random().toString(16).slice(2, 8).toUpperCase();
        });

        updateChords(matrixJson);


        /* Create OR update a chord layout from a data matrix */
        function updateChords(matrix) {
            layout = getDefaultLayout();
            layout.matrix(matrix);

            /* Create/update "group" elements */
            var groupG = g.selectAll("g.group")
                .data(layout.groups(), function (d) {
                    return d.index;
                    //use a key function in case the
                    //groups are sorted differently between updates
                });

            groupG.exit()
                .transition()
                .duration(1500)
                .attr("opacity", 0.5)
                .remove(); //remove after transitions are complete

            var newGroups = groupG.enter().append("g")
                .attr("class", "group");
            //the enter selection is stored in a variable so we can
            //enter the <path>, <text>, and <title> elements as well


            //Create the title tooltip for the new groups
            newGroups.append("title");

            //Update the (tooltip) title text based on the data
            groupG.select("title")
                .text(function (d, i) {
                    return numberWithCommas(d.value) +
                        " trips started in " +
                        taxizones[i].name;
                });

            //create the arc paths and set the constant attributes
            //(those based on the group index, not on the value)
            newGroups.append("path")
                .attr("id", function (d) {
                    return "group" + d.index;
                    //using d.index and not i to maintain consistency
                    //even if groups are sorted
                })
                .style("fill", function (d) {
                    return taxizones[d.index].color;
                });

            //update the paths to match the layout
            groupG.select("path")
                .transition()
                .duration(1500)
                .attr("opacity", 0.5) //optional, just to observe the transition
                .attr("d", arc)
                .transition().duration(10).attr("opacity", 1) //reset opacity
                ;

            //create the group labels
            newGroups.append("svg:text")
                .attr("xlink:href", function (d) {
                    return "#group" + d.index;
                })
                .attr("dy", ".35em")
                .attr("color", "#fff")
                .text(function (d) {
                    return taxizones[d.index].name;
                });

            //position group labels to match layout
            groupG.select("text")
                .transition()
                .duration(1500)
                .attr("transform", function (d) {
                    d.angle = (d.startAngle + d.endAngle) / 2;
                    //store the midpoint angle in the data object

                    return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")" +
                        " translate(" + (innerRadius + 26) + ")" +
                        (d.angle > Math.PI ? " rotate(180)" : " rotate(0)");
                    //include the rotate zero so that transforms can be interpolated
                })
                .attr("text-anchor", function (d) {
                    return d.angle > Math.PI ? "end" : "begin";
                });


            var chordPaths = g.selectAll("path.chord")
                .data(layout.chords(), chordKey);

            var newChords = chordPaths.enter()
                .append("path")
                .attr("class", "chord");


            newChords.append("title");

            chordPaths.select("title")
                .text(function (d) {
                    if (taxizones[d.target.index].name !== taxizones[d.source.index].name) {
                        return [numberWithCommas(d.source.value),
                            " trips from ",
                        taxizones[d.source.index].name,
                            " to ",
                        taxizones[d.target.index].name,
                            "\n",
                        numberWithCommas(d.target.value),
                            " trips from ",
                        taxizones[d.target.index].name,
                            " to ",
                        taxizones[d.source.index].name
                        ].join("");
                    } else {
                        return numberWithCommas(d.source.value) +
                            " trips started and ended in " +
                            taxizones[d.source.index].name;
                    }
                });

            chordPaths.exit().transition()
                .duration(1500)
                .attr("opacity", 0)
                .remove();

            chordPaths.transition()
                .duration(1500)
                .attr("opacity", 0.5)
                .style("fill", function (d) {
                    return taxizones[d.source.index].color;
                })
                .attr("d", path)
                .transition().duration(10).attr("opacity", 1) //reset opacity
                ;

            groupG.on("mouseover", function (d) {
                chordPaths.classed("fade", function (p) {
                    return ((p.source.index != d.index) && (p.target.index != d.index));
                });
            });

            last_layout = layout;
        }

        function arcTween(oldLayout) {
            var oldGroups = {};
            if (oldLayout) {
                oldLayout.groups().forEach(function (groupData) {
                    oldGroups[groupData.index] = groupData;
                });
            }

            return function (d, i) {
                var tween;
                var old = oldGroups[d.index];
                if (old) { //there's a matching old group
                    tween = d3.interpolate(old, d);
                } else {
                    //create a zero-width arc object
                    var emptyArc = {
                        startAngle: d.startAngle,
                        endAngle: d.startAngle
                    };
                    tween = d3.interpolate(emptyArc, d);
                }

                return function (t) {
                    return arc(tween(t));
                };
            };
        }

        function chordKey(data) {
            return (data.source.index < data.target.index) ?
                data.source.index + "-" + data.target.index :
                data.target.index + "-" + data.source.index;
        }

        function chordTween(oldLayout) {

            var oldChords = {};

            if (oldLayout) {
                oldLayout.chords().forEach(function (chordData) {
                    oldChords[chordKey(chordData)] = chordData;
                });
            }

            return function (d, i) {

                var tween;
                var old = oldChords[chordKey(d)];
                if (old) {
                    if (d.source.index != old.source.index) {
                        old = {
                            source: old.target,
                            target: old.source
                        };
                    }

                    tween = d3.interpolate(old, d);
                } else {
                    //create a zero-width chord object
                    var emptyChord = {
                        source: {
                            startAngle: d.source.startAngle,
                            endAngle: d.source.startAngle
                        },
                        target: {
                            startAngle: d.target.startAngle,
                            endAngle: d.target.startAngle
                        }
                    };
                    tween = d3.interpolate(emptyChord, d);
                }

                return function (t) {
                    return path(tween(t));
                };
            };
        }


        d3.select("#PU").on("click", function () {
            var matrixJson = [
                [1, 10, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0],
                [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0],
                [10, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
                [0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 1, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 0, 0, 1, 0, 0, 4, 0, 0, 11, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0],
                [0, 0, 0, 0, 0, 0, 1, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
                [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 10, 1, 0, 0, 0, 0, 0, 1, 1, 0],
                [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0],
                [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0],
                [1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 9, 0, 0, 1, 1, 0, 1, 1, 0],
                [1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0],
                [1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 7, 1, 0, 0, 1, 0, 0],
                [0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 1, 0, 0],
                [0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0],
                [0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]
            ];
            updateChords(matrixJson);
            disableButton(this);
        });

        d3.select("#DO").on("click", function () {
            var matrixJson = [
                [1, 10, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0],
                [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0],
                [10, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
                [0, 0, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 1, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 0, 0, 1, 0, 0, 4, 0, 0, 11, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0],
                [0, 0, 0, 0, 0, 0, 1, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
                [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 10, 1, 0, 0, 0, 0, 0, 1, 1, 0],
                [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0],
                [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0],
                [1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 9, 0, 0, 1, 1, 0, 1, 1, 0],
                [1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0],
                [1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 7, 1, 0, 0, 1, 0, 0],
                [0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0, 0, 1, 0, 0],
                [0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0],
                [0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]
            ];
            updateChords(matrixJson);
            disableButton(this);
        });

        function disableButton(buttonNode) {
            d3.selectAll("button")
                .attr("disabled", function (d) {
                    return this === buttonNode ? "true" : null;
                });
        }
    </script>
</div>

@section scripts {
    <script>
        var taxizones = [{
            "name": "A"
        },
        {
            "name": "B"
        },
        {
            "name": "C"
        },
        {
            "name": "D"
        },
        {
            "name": "E"
        },
        {
            "name": "F"
        },
        {
            "name": "Detroit"
        },
        {
            "name": "Denver"
        },
        {
            "name": "Houston"
        },
        {
            "name": "Los Angeles"
        },
        {
            "name": "Kansas City"
        },
        {
            "name": "Miami"
        },
        {
            "name": "New York"
        },
        {
            "name": "Philadelphia"
        },
        {
            "name": "Oakland"
        },
        {
            "name": "Pittsburgh"
        },
        {
            "name": "Seattle"
        },
        {
            "name": "San Diego"
        },
        {
            "name": "Tampa Bay"
        },
        {
            "name": "Washington DC"
        }
        ];

        var matrixJson = [
            [45, 49, 45, 74, 26, 18, 2, 4, 0, 9],
            [63, 16, 25, 51, 14, 4, 4, 7, 0, 22],
            [61, 36, 44, 27, 34, 14, 5, 5, 0, 17],
            [27, 24, 55, 9, 46, 20, 7, 2, 0, 5],
            [18, 58, 12, 6, 15, 9, 9, 4, 0, 24],
            [0, 0, 0, 0, 0, 0, 0, 6, 57, 0],
            [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 2, 0, 0],
            [4, 12, 2, 2, 3, 14, 28, 0, 0, 4],
            [1, 12, 9, 2, 17, 14, 18, 0, 0, 2]
        ];



        $(function () {
            $("#slider").slider({
                // orientation: 'vertical',
                range: "max",
                value: 2,
                min: 1,
                max: 20,
                slide: function (event, ui) {
                    $("#amount").val(ui.value);
                    var max = $("#slider").slider("option", "max");
                    var min = $("#slider").slider("option", "min") - 1;
                    var newJson = $.extend(true, [], matrixJson);
                    newJson.splice(ui.value - min, max - ui.value);
                    newJson.forEach(function (element, i) {
                        element.splice(ui.value - min, max - ui.value);
                    }, this);
                    updateChords(newJson);
                }
            });
            $("#amount").val($("#slider").slider("value"));
        });
    </script>
}