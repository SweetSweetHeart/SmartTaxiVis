<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"helper.js.html":{"id":"helper.js.html","title":"Source: helper.js","body":" Smart Taxi Vis Modules HelperVis/ChordDiagramVis/HistogramVis/MapView Source: helper.js /** * @author Qiru Wang 689404@swansea.ac.uk * * @module Helper */ $(() =&gt; { // generateChordColorLegend(); initGlobalVariables(); initSliders(); initChordDiagram(); formatJSON(); $('[data-toggle=&quot;popover&quot;]').popover({ trigger: 'manual', }); $('#hourSlider').popover('show'); $('#zoneSlider').popover('show'); $('#btn_pause').click(() =&gt; { toggleAnimation(false); }); $('#histogramZone, #histogramHour').change(() =&gt; { generateHistogram(); toggleAnimation(true); }); $('#chordTripPU,#chordTripDO,#chordPrice,#chordDistance').change(() =&gt; { formatJSON(); toggleAnimation(true); }); chordAnimation(); }); /** * Initialise global variables needed for the application. * */ function initGlobalVariables() { // Some global variables needed. /** * Total number of taxi zones. * @type {number} */ TOTALZONENUM = 263; /** * Starting index of taxi zones selected. * @type {number} */ ZONE1 = 1; /** * Ending index of taxi zones selected. * @type {number} */ ZONE2 = 40; /** * Starting index of hours selected. * @type {number} */ TIME1 = 9; $('#hour').html(TIME1); /** * Starting index of hours selected. * @type {number} */ TIME2 = 15; /** * A noUiSlider for taxi zones. * @type {noUiSlider} * @see {@link https://refreshless.com/nouislider/} */ ZONESLIDER = document.getElementById('zoneSlider'); /** * A noUiSlider for hours of the day. * @type {noUiSlider} * @see {@link https://refreshless.com/nouislider/} */ HOURSLIDER = document.getElementById('hourSlider'); // Some default values to play with, before the server returns actual data /** * The point that represents a taxizone, corresponding to the clicked path on Chord Diagram. * @type {anychart.core.SeriesPoint} * @see {@link https://api.anychart.com/7.14.3/anychart.core.SeriesPoint} */ POINTCLICKED = null; /** * Store the last Chord layout for next update. * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Chord-Layout.md#chord} * @returns {d3.layout} - The sorted D3 Chord Diagram layout. */ LASTLAYOUT = null; /** * Store an anymap instance. * @see {@link https://api.anychart.com/7.14.3/anychart.charts.Map} */ MAP = null; /** * Store the current taxi zones. * @type {string} */ ZONE_HOLDER = null; /** * Store the current taxi zone data. * @type {string} */ DATA_HOLDER = null; } /** * Initialise a noUiSlider for zones and hours. * @see {@link https://refreshless.com/nouislider/} */ function initSliders() { noUiSlider.create(ZONESLIDER, { tooltips: true, format: wNumb({ decimals: 0, }), start: [1, ZONE2], step: 1, behaviour: 'drag-tap', connect: true, range: { min: 1, max: TOTALZONENUM, }, }); ZONESLIDER.noUiSlider.on('change', (values) =&gt; { ZONE1 = parseInt(values[0]); ZONE2 = parseInt(values[1]); toggleAnimation(true); formatJSON(); }); noUiSlider.create(HOURSLIDER, { tooltips: true, animate: true, format: wNumb({ decimals: 0, }), start: TIME1, step: 1, range: { min: [0], max: [23], }, }); HOURSLIDER.noUiSlider.on('change', (values) =&gt; { TIME1 = parseInt(values[0]); animationSetData(); toggleAnimation(true); formatJSON(); }); } /** * Return the current data dimension being visualised. * * @returns {string} - The current data dimension being visualised. */ function getDataDimension() { if ($('#chordTripPU').is(':checked') || $('#chordTripDO').is(':checked')) { return 'trip'; } else if ($('#chordPrice').is(':checked')) { return 'price'; } else if ($('#chordDistance').is(':checked')) { return 'distance'; } } /** * Splice the input array based on the ZONE_HOLDER selected. * * @param {number[]|string[]} matrix - A matrix that contains the input data. * @returns {number[]|string[]} - The spliced array with the selected ZONE_HOLDER only. */ function spliceMatrix(matrix) { matrix.splice(0, ZONE1 - 1); matrix.splice(ZONE2 - (ZONE1 - 1), matrix.length); return matrix; } /** * Splice the input nested array based on the ZONE_HOLDER selected, for data count matrix. * * @param {number[]} matrix - A matrix that contains the input data. * @returns {number[]} - The spliced array with the selected ZONE_HOLDER only. */ function spliceSubTripMatrix(matrix) { jQuery.each(matrix, (i, val) =&gt; { spliceMatrix(val); }); return matrix; } /** * Toggle the display of 'No Match' message, visulisations and controls. * @deprecated since issue #12 Dynamic ranged colormap. * @param {boolean} toggle - If True: displays the message. */ function toggleNoMatchMessage(toggle) { if (!toggle) { $('.visualisationRow:hidden').show(); $('.controlRow:hidden').show(); $('#nomatch:visible').hide(); } else { $('.visualisationRow:visible').hide(); $('.controlRow:visible').hide(); $('#nomatch:hidden').show(); } } /** * Iterate the input matrix and sum up all count. Also calcualte the largest and the smallest values in the input data. * * @param {Array.&lt;number[]&gt;} data - A matrix that contains the input data * @returns {number[]} - An array with total data count, the largest and the smallest values in the input data. */ function getTotalDataCount(data) { let dataCount = 0; let maxCount = 0; let minCount = 0; jQuery.each(data, (i, val) =&gt; { const count = getIndividualDataCount(val); dataCount += count; if (count &gt; maxCount) { maxCount = count; } if (count &lt; minCount) { minCount = count; } }); return [dataCount, maxCount, minCount]; } /** * Calculate the given data count. * * @param {string} data - The input data count data in JSON. * @returns {number[]} - The total data count. */ function getIndividualDataCount(data) { let count = 0; jQuery.each(data, (i, val) =&gt; { count += parseInt(val); }); return count; } /** * Based on the largest and the smallest data count for all ZONE_HOLDER, generate a set of colors for ZONE_HOLDER on the Chord Diagram. * * @param {string[]} zone - A matrix that contains input taxi ZONE_HOLDER. * @param {number} maxCount - The largest data count for all ZONE_HOLDER. * @param {number} minCount - The smallest data count for all ZONE_HOLDER. */ function generateColorForZone(zone, maxCount, minCount) { jQuery.each(zone, (i, val) =&gt; { val.color = generateRainBowColorMap(getIndividualDataCount(DATA_HOLDER[i]), maxCount, minCount); }); } /** * Generate a rainbow color map based on the ratio of data count and the min/max data count. * * @param {number} count - Data count of one zone as the dividend. * @param {number} max - Max data count in the selected dataset. * @param {number} min - Min data count in the selected dataset. * @returns {string} - A HSL color. */ function generateRainBowColorMap(count, maxCount, minCount) { const maxHue = 220; let hue = (count - minCount) / (maxCount - minCount); hue = (maxHue - hue * maxHue); // if (lowerColor &gt; i) // lowerColor = i; // if (higherColor &lt; i) // higherColor = i; return `hsl(${hue},90%,50%)`; } /** * Update the hour for the HTML element. * * @param {number} hour - The hour used. */ function setHourHTML(hour) { $('#hour').html(hour); } /** * Update the data count for the HTML element. * * @param {number} count - The data count used. */ function setDataCountHTML(count) { const dimension = getDataDimension(); if (dimension === 'trip') { $('#dataCount').html(count); $('#dataCountLabel').show(); } else { $('#dataCountLabel').hide(); } } × Search results Close "},"chordDiagram.js.html":{"id":"chordDiagram.js.html","title":"Source: chordDiagram.js","body":" Smart Taxi Vis Modules HelperVis/ChordDiagramVis/HistogramVis/MapView Source: chordDiagram.js /** * @author Qiru Wang 689404@swansea.ac.uk * * @module Vis/ChordDiagram * @requires Helper */ function generateChordDiagram() { const dimension = getDataDimension(); if (dimension === 'trip') { if ($('#chordTripPU').is(':checked')) { DATA_HOLDER = $.extend(true, [], PU_MATRIX[TIME1]); zoneT = $.extend(true, [], ZONE_PU_MATRIX); } else if ($('#chordTripDO').is(':checked')) { DATA_HOLDER = $.extend(true, [], DO_MATRIX[TIME1]); zoneT = $.extend(true, [], ZONE_DO_MATRIX); } } else if (dimension === 'price') { DATA_HOLDER = $.extend(true, [], PRICE_MATRIX[TIME1]); zoneT = $.extend(true, [], ZONE_AVG_PRICE_MATRIX); } else if (dimension === 'distance') { DATA_HOLDER = $.extend(true, [], DISTANCE_MATRIX[TIME1]); zoneT = $.extend(true, [], ZONE_AVG_DISTANCE_MATRIX); } TOTALZONENUM = DATA_HOLDER.length; ZONESLIDER.noUiSlider.updateOptions({ range: { min: 1, max: DATA_HOLDER.length, }, }); ZONE_HOLDER = $.extend(true, [], zoneT[TIME1]); spliceMatrix(ZONE_HOLDER); spliceMatrix(DATA_HOLDER); spliceSubTripMatrix(DATA_HOLDER); const counts = getTotalDataCount(DATA_HOLDER); setDataCountHTML(counts[0]); generateColorForZone(ZONE_HOLDER, counts[1], counts[2]); } /** * Trigger all necessary functions when data is changed. E.g. Re-render Chord Diagram, Map Diagram and Histogram. * Also update the visibility of some HTML elements. */ function formatJSON() { generateChordDiagram(); generateHistogram(); generateMap(); /** * Dataset for AnyMap. * @see {@link https://api.anychart.com/7.14.3/anychart.data.Set} * @type {anychart.data.Set} */ const dataSet = anychart.data.set(ZONE_HOLDER); connectorData = null; updateChordDiagram(DATA_HOLDER); } /** * Highlight the current range of colors used on the colormap legend. Also reset global variables: lowerColor and higherColor. * @deprecated since issue #12 Dynamic ranged colormap. * @param {number} low - The hue of the color for the largest data value. * @param {number} high - The hud of the color for the smallest data value. */ function highlightColormapLegend(low, high) { const colorInterval = 3; $('#chordColorLegend font').css({ 'border-style': 'none ', 'border-width': '7px', }); $(`#color${Math.ceil(low / colorInterval) * colorInterval}`).css({ 'border-style': 'solid none solid solid', }); $(`#color${Math.ceil((high / colorInterval) - 1) * colorInterval}`).css({ 'border-style': 'solid solid solid none', }); for (let index = (Math.ceil(low / colorInterval) + 1) * colorInterval; index &lt; Math.ceil((high / colorInterval) - 1) * colorInterval; index += colorInterval) { $(`#color${index}`).css({ 'border-style': 'solid none solid none', }); } } /** * Start the animation for Chord Diagram. * */ function chordAnimation() { const lastHour = 23; const animationInterval = 3000; isPaused = false; interval = setInterval(() =&gt; { if (!isPaused) { TIME1++; if (TIME1 &gt; lastHour) { TIME1 = 0; } animationSetData(); } }, animationInterval); } /** * Update hourSlider and HTML element 'Hour of the day' to the corresponding hour animated. * */ function animationSetData() { hourSlider.noUiSlider.set(TIME1); setHourHTML(TIME1); formatJSON(); } /** * Toggle the animation state based on the input boolean value. * @param {boolean} pausing - The input boolean value. */ function toggleAnimation(pausing) { if (pausing) { isPaused = true; $('#btn_pause').html(&quot;&lt;i class='fa fa-play' aria-hidden='true'&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;Animation&quot;); } else if (!isPaused) { isPaused = true; $('#btn_pause').html(&quot;&lt;i class='fa fa-play' aria-hidden='true'&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;Animation&quot;); } else { isPaused = false; $('#btn_pause').html(&quot;&lt;i class='fa fa-pause' aria-hidden='true'&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;Animation&quot;); } } /** * Sort the Chord Diagram. * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Chord-Layout.md#chord} * @returns {d3.layout} - The sorted D3 Chord Diagram layout. */ function getDefaultLayout() { return d3.layout.chord() .padding(0.03) .sortSubgroups(d3.descending) .sortChords(d3.ascending); } /** * Generate a legend for Chord Diagram based on the color map used. * @deprecated since issue #13 Dynamically update zoneSlider's range. */ function generateChordColorLegend() { let text = ''; for (let index = 0; index &lt; 20; index++) { text += `&lt;font id=&quot;color${index}&quot; style=&quot;color:hsl(${index * 11},90%,53%)&quot;&gt;█&lt;/font&gt;`; } console.log(text); $('#chordColorLegend').empty(); $('#chordColorLegend').append('Legend: &amp;nbsp; &amp;nbsp; &amp;nbsp; Max '); chordLegendColor = Array.from(new Set(chordLegendColor)); chordLegendColor.sort((a, b) =&gt; a - b); let last; jQuery.each(chordLegendColor, (i, val) =&gt; { if ((last == null) || (last != null &amp;&amp; val &gt; (last + 1))) { $('#chordColorLegend').append(`&lt;font style=color:hsl(${val},90%,53%)&gt;█&lt;/font&gt;`); } last = val; }); $('#chordColorLegend').append(' Min'); chordLegendColor = []; } /** * Initialise a Chord Diagram. * */ function initChordDiagram() { const targetSize = $('#chordDiagram').width() * 0.85; const marginBetweenLabelAndChord = 50; const chordRadiusWidth = 18; const half = 2; $(window).resize(() =&gt; { const svg = d3.select('#chordDiagram') .attr('width', targetSize) .attr('height', targetSize); outerRadius = targetSize / half - marginBetweenLabelAndChord; innerRadius = outerRadius - chordRadiusWidth; arc = d3.svg.arc() .innerRadius(innerRadius) .outerRadius(outerRadius); path = d3.svg.chord() .radius(innerRadius); $('#circle').attr('r', outerRadius); $('[data-toggle=&quot;popover&quot;]').popover('show'); }); outerRadius = targetSize / half - marginBetweenLabelAndChord; innerRadius = outerRadius - chordRadiusWidth; viewBoxDimensions = `0 0 ${targetSize} ${targetSize}`; // Create the arc path data generator for the groups arc = d3.svg.arc() .innerRadius(innerRadius) .outerRadius(outerRadius); // Create the chord path data generator for the chords path = d3.svg.chord() .radius(innerRadius); LASTLAYOUT = getDefaultLayout(); // store layout between updates // Initialize the visualization g = d3.select('#chordDiagram').append('svg') .attr('viewBox', viewBoxDimensions) .attr('preserveAspectRatio', 'xMinYMid') .append('g') .attr('id', 'circle') .attr('overflow-x', 'visible') .attr('transform', `translate(${targetSize / half},${targetSize / half})`); g.append('circle') .attr('r', outerRadius); } /** * Format the text appeared when mouse hover the path. * * @param {string} path - A JSON string that contains the source and the target chord of the path. * @param {boolean} innerZone - If the path if representing the inner zone trips. * @returns {string} - THe text appeared when mouse hover the path. */ function formatPathTitle(path) { let label = ''; let prefix = ''; let suffix = ''; const dataFixer = 100; let formatNumber = d3.format('.2f'); const dimension = getDataDimension(); const innerZone = ZONE_HOLDER[path.target.index].ZoneName === ZONE_HOLDER[path.source.index].ZoneName; /** For inner zone trip, source and target are referenced, multiply by 100 to avoid double division later */ if (innerZone &amp;&amp; dimension !== 'trip') { path.source.value = path.source.value * dataFixer; } if (dimension === 'trip') { formatNumber = d3.format('2,f'); path.source.value = formatNumber(path.source.value); path.target.value = formatNumber(path.target.value); suffix = ' '; label = ' trips from '; } else if (dimension === 'price') { path.source.value = formatNumber(path.source.value / dataFixer); path.target.value = formatNumber(path.target.value / dataFixer); label = ' from '; prefix = '$'; suffix = ' for '; } else if (dimension === 'distance') { path.source.value = formatNumber(path.source.value / dataFixer); path.target.value = formatNumber(path.target.value / dataFixer); label = ' km from '; suffix = ' km for '; } if (!innerZone) { return [prefix, path.source.value, label, ZONE_HOLDER[path.source.index].ZoneName, ' to ', ZONE_HOLDER[path.target.index].ZoneName, '\\n', prefix, path.target.value, label, ZONE_HOLDER[path.target.index].ZoneName, ' to ', ZONE_HOLDER[path.source.index].ZoneName, ].join(''); } return `${prefix + path.source.value + suffix}inner zone trips within ${ ZONE_HOLDER[path.source.index].ZoneName}`; } /** * Format the text appeared when mouse hover the chord. * * @param {string} chord - A JSON string that contains the chord. * @param {number} index - The index of the taxi zone represented by the chord. * @returns {string} - The text appeared when mouse hover the chord. */ function formatChordTitle(chord, index) { let label = ''; const prefix = ''; let formatNumber = d3.format('.2f'); const dataFixer = 100; const dimension = getDataDimension(); if (dimension === 'trip') { formatNumber = d3.format('2,f'); chord.value = formatNumber(chord.value); label = ' trips '; return `${prefix + chord.value + label}for ${ZONE_HOLDER[index].ZoneName}`; } // else if (dimension === 'price') { // chord.value = formatNumber(chord.value / dataFixer); // label = &quot; sum of average fare &quot;; // prefix = &quot;$&quot;; // } else if (dimension === 'distance') { // chord.value = formatNumber(chord.value / dataFixer); // label = &quot; sum of average distance &quot;; // } } /** * Update the chords for Chord Diagram. Add event listeners, transition effects and many minor tweaks to Chord Diagram. * * @param {Array.&lt;number[]&gt;} matrix - A matrix that contains the input data. */ function updateChordDiagram(matrix) { const durationLong = 800; const durationShort = 10; const opacity = 0.5; // Remove empty svg generated by animation loop. $('svg[width=0]').remove(); layout = getDefaultLayout(); layout.matrix(matrix); // Create/update &quot;group&quot; elements const groupG = g.selectAll('g.group') .data(layout.groups(), d =&gt; d.index); groupG.exit().transition().duration(durationLong) .attr('opacity', opacity).remove(); // Remove after transitions are complete const newGroups = groupG.enter().append('g').attr('class', 'group'); // Create the title tooltip for the new groups newGroups.append('title'); // Update the (tooltip) title text based on the data groupG.select('title').text((d, i) =&gt; formatChordTitle(d, i)); // create the arc paths and set the constant attributes // (those based on the group index, not on the value) newGroups.append('path').attr('id', d =&gt; `group${d.index}`) .style('fill', d =&gt; ZONE_HOLDER[d.index].color); // Update the paths to match the layout and color groupG.select('path').transition().duration(durationLong) .attr('opacity', opacity).attr('d', arc) .attrTween('d', arcTween(LASTLAYOUT)) .style('fill', d =&gt; ZONE_HOLDER[d.index].color) .transition().duration(durationShort).attr('opacity', 1) // reset opacity ; newGroups.append('svg:text').attr('xlink:href', d =&gt; `#group${d.index}`) .attr('dy', '.35em').attr('color', '#fff') .text(d =&gt; ZONE_HOLDER[d.index].ZoneName); // Position group labels to match layout groupG.select('text').text(d =&gt; ZONE_HOLDER[d.index].ZoneName) .attr('transform', d =&gt; calculateLabelRotation(d)) .attr('text-anchor', d =&gt; (d.angle &gt; Math.PI ? 'end' : 'begin')); const chordPaths = g.selectAll('path.chord') .data(layout.chords(), chordKey); const newChords = chordPaths.enter() .append('path').attr('class', 'chord'); newChords.append('title'); chordPaths.select('title') .text(d =&gt; formatPathTitle(d)); chordPaths.exit().transition() .duration(durationLong) .attr('opacity', 0).remove(); chordPaths.transition().duration(durationLong) .attr('opacity', opacity) .style('fill', d =&gt; ZONE_HOLDER[d.source.index].color) .attrTween('d', chordTween(LASTLAYOUT)).attr('d', path) .transition().duration(durationShort).attr('opacity', 1); groupG.on('mouseover', (d) =&gt; { toggleAnimation(true); chordPaths.classed('fade', p =&gt; ((p.source.index != d.index) &amp;&amp; (p.target.index != d.index))); }); chordPaths.on('mouseover', function (d) { toggleAnimation(true); chordPaths.attr('opacity', 0.2); $(this).attr('opacity', 1); }); groupG.on('click', (d) =&gt; { chordToConnector(d.index); }); chordPaths.on('click', (d) =&gt; { pathToConnector(ZONE_HOLDER[d.source.index], ZONE_HOLDER[d.target.index], d.source.value); }); chordPaths.on('mouseout', () =&gt; { chordPaths.attr('opacity', opacity); }); g.on('mouseout', function () { if (this == g.node()) { // Only respond to mouseout of the entire circle not mouseout events for sub-components chordPaths.classed('fade', false); } }); LASTLAYOUT = layout; } /** * Calculate the rotation angle for label of the chord. * * @param {string} input - Contains the JSON data for a chord * @returns The rotation and translation angles for the label. */ function calculateLabelRotation(input) { input.angle = (input.startAngle + input.endAngle) / 2; return `rotate(${input.angle * 180 / Math.PI - 90})` + ` translate(${innerRadius + 26})${ input.angle &gt; Math.PI ? ' rotate(180)' : ' rotate(0)'}`; } /** * Format the data from the clicked paht on Chord Diagram, and display the connector on Map. * * @param {string} source - The origination taxi zone. * @param {string} target - The destination taxi zone. * @param {string} value - The number of trips. */ function pathToConnector(source, target, value) { const pointData = getConnector(source.ZoneId, target.ZoneId); if (source.ZoneId != target.ZoneId) { /** * Connector dataset for AnyMap. * @see {@link https://docs.anychart.com/7.14.3/Maps/Connector_Maps} * @type {anychart.data.Set} */ const connectorData = [{ points: pointData, from: source.ZoneName, to: target.ZoneName, data: value, color: source.color, weight: 0, }]; addConnectorSeries(connectorData); } else { removeConnectorSeries(); } highlightPoint(source, true); toggleAnimation(true); } function chordToConnector(index) { const source = ZONE_HOLDER[index]; const connectorData = []; jQuery.each(DATA_HOLDER[index], (i, val) =&gt; { if (index !== i &amp;&amp; val !== 0) { const pointData = getConnector(source.ZoneId, ZONE_HOLDER[i].ZoneId); const connector = {}; connector.points = pointData; connector.from = source.ZoneName; connector.to = ZONE_HOLDER[i].ZoneName; connector.data = val; connector.weight = val / source.Data; connector.color = ZONE_HOLDER[i].color; connectorData.push(connector); } }); addConnectorSeries(connectorData); highlightPoint(source, false); } function arcTween(oldLayout) { const oldGroups = {}; if (oldLayout) { oldLayout.groups().forEach((groupData) =&gt; { oldGroups[groupData.index] = groupData; }); } return function (d, i) { let tween; const old = oldGroups[d.index]; if (old) { // There's a matching old group tween = d3.interpolate(old, d); } else { // Create a zero- width arc object const emptyArc = { startAngle: d.startAngle, endAngle: d.startAngle, }; tween = d3.interpolate(emptyArc, d); } return function (t) { return arc(tween(t)); }; }; } function chordKey(data) { return (data.source.index &lt; data.target.index) ? `${data.source.index}-${data.target.index}` : `${data.target.index}-${data.source.index}`; } function chordTween(oldLayout) { const oldChords = {}; if (oldLayout) { oldLayout.chords().forEach((chordData) =&gt; { oldChords[chordKey(chordData)] = chordData; }); } return function (d, i) { let tween; let old = oldChords[chordKey(d)]; if (old) { if (d.source.index != old.source.index) { old = { source: old.target, target: old.source, }; } tween = d3.interpolate(old, d); } else { // Create a zero- width chord object const emptyChord = { source: { startAngle: d.source.startAngle, endAngle: d.source.startAngle, }, target: { startAngle: d.target.startAngle, endAngle: d.target.startAngle, }, }; tween = d3.interpolate(emptyChord, d); } return function (t) { return path(tween(t)); }; }; } × Search results Close "},"histogram.js.html":{"id":"histogram.js.html","title":"Source: histogram.js","body":" Smart Taxi Vis Modules HelperVis/ChordDiagramVis/HistogramVis/MapView Source: histogram.js /** * @author Qiru Wang 689404@swansea.ac.uk * * @module Vis/Histogram * @requires Helper */ /** * Start generating histogram. * */ function generateHistogram() { if ($('#histogramZone').is(':checked')) { generateZoneHistogramData(); } if ($('#histogramHour').is(':checked')) { generateHourHistogramData(); } } /** * Generate data for Hour Histogram. * */ function generateHourHistogramData() { const histogramData = []; let dataMatrix = PU_MATRIX; if ($('#chordTripPU').is(':checked')) { dataMatrix = PU_MATRIX; } else if ($('#chordTripDO').is(':checked')) { dataMatrix = DO_MATRIX; } for (let i = 0; i &lt; dataMatrix.length; i++) { const data = $.extend(true, [], dataMatrix[i]); spliceMatrix(data); spliceSubTripMatrix(data); var dataCount = 0; jQuery.each(data, (i, val) =&gt; { dataCount += getIndividualDataCount(val); }); if (i === TIME1) { histogramData.push([i.toString(), dataCount, '#e74c3c']); } else { histogramData.push([i.toString(), dataCount]); } } renderHistogram(histogramData, 'hour'); } /** * Generate data for Zone Histogram. * */ function generateZoneHistogramData() { const histogramData = []; const zoneData = $.extend(true, [], zoneT[TIME1]); spliceMatrix(zoneData); const counts = getTotalDataCount(DATA_HOLDER); generateColorForZone(zoneData, counts[1], counts[2]); jQuery.each(zoneData, (i, val) =&gt; { histogramData.push([val.ZoneName, val.Data, val.color]); }); renderHistogram(histogramData, 'zone'); } /** * Render the Histogram with input data and type. * * @param {Array.&lt;any[]&gt;} input - The input data for histogram. * @param {string} type - Type of the histogram to be rendered, either Zone or Hour. */ function renderHistogram(input, type) { $('#histogram').empty(); const inputData = anychart.data.set(input); // create a chart histogramChart = anychart.column(); const credits = histogramChart.credits(); credits.enabled(false); // create a column series and set the data const dataMap = inputData.mapAs({ x: [0], value: [1], fill: [2], stroke: [2], }); const series = histogramChart.column(dataMap); let label; const dimension = getDataDimension(); if (dimension === 'trip') { label = 'Trips: '; } else if (dimension === 'price') { label = 'Price: '; } else if (dimension === 'distance') { label = 'Distance: '; } series.tooltip() .useHtml(true) .title(false) .separator(false) .fontSize(14) .format(function () { if (type === 'hour') { return `&lt;span&gt;Hour: ${this.getData('x')} to ${parseInt(this.getData('x')) + 1} &lt;br/&gt;${label}${this.getData('value')}&lt;/span&gt;`; } return `&lt;span&gt;Taxizone: ${this.getData('x')} &lt;br/&gt;${label}${this.getData('value')}&lt;/span&gt;`; }); if (type === 'hour') { var xAxis = histogramChart.xAxis().title('Hour'); histogramChart.listen('pointClick', (e) =&gt; { TIME1 = e.pointIndex; animationSetData(); toggleAnimation(true); }); } else { var xAxis = histogramChart.xAxis().title('Zone'); histogramChart.listen('pointClick', (e) =&gt; { highlightZone(ZONE_HOLDER[e.pointIndex].ZoneId); toggleAnimation(true); }); } const yAxis = histogramChart.yAxis().title('Trips').orientation('left'); histogramChart.contextMenu(false); histogramChart.barGroupsPadding(0); histogramChart.container('histogram').draw(); } × Search results Close "},"mapDiagram.js.html":{"id":"mapDiagram.js.html","title":"Source: mapDiagram.js","body":" Smart Taxi Vis Modules HelperVis/ChordDiagramVis/HistogramVis/MapView Source: mapDiagram.js /** * @author Qiru Wang 689404@swansea.ac.uk * * @module Vis/MapView * @requires Helper */ $(window).resize(() =&gt; { $('#anymap').css('height', $('#anymap').css('width')); }); anychart.licenseKey('689404@swansea.ac.uk-52d848b-7c97169e'); /** * Render a Choropleth MAP as base series, add Marker series on top of the base series. */ function generateMap() { $('#anymap').empty(); MAP = anychart.map(); const credits = MAP.credits(); credits.enabled(false); /** Create a AnyMap base MAP */ MAP.unboundRegions() .enabled(true) .fill('#E1E1E1') .stroke('#D2D2D2'); /** Map geojson data for drawing taxizone contours */ MAP.geoData('anychart.maps.taxizone'); /** IMPORTANT!!! MAP ID field to geojson ID field */ MAP.geoIdField('LocationID'); const choroplethSeries = MAP.choropleth(connectorBase); choroplethSeries.id('choropleth'); choroplethSeries.enabled(false); choroplethSeries.legendItem().enabled(false); jQuery.each(ZONE_HOLDER, (i, val) =&gt; { const seriesData = anychart.data.set([val]); /** Map data attributes. * @type {anychart.data.Mapping} * @see {@link https://api.anychart.com/7.14.3/anychart.data.Set#mapAs} */ const newSeries = seriesData.mapAs(null, { name: 'ZoneName', id: 'ZoneId', size: 'Data', color: 'color', }); createMarkerSeries(val.ZoneName, newSeries, val.color); }); /** Disable MAP legend */ MAP.legend().enabled(false); /** * Create zoom controllers for the MAP. * @type {anychart.ui.Zoom} * @see {@link https://api.anychart.com/7.14.3/anychart.ui#zoom} */ const zoomController = anychart.ui.zoom(); zoomController.render(MAP); /** Disable context menu */ MAP.contextMenu(false); /** Set MAP inteactions */ const interactivity = MAP.interactivity(); interactivity.zoomOnMouseWheel(true); interactivity.zoomOnDoubleClick(true); /** Initiates the drawing into the div with id anymap */ MAP.container('anymap').draw(); $('#anymap').css('height', $('#anymap').css('width')); } /** * Create a marker series. * * @param {string} name - Name of the marker series. * @param {any} input - Data of the marker series. * @param {string} color - Color of the marker series. * @see {@link https://api.anychart.com/7.14.3/anychart.charts.Map#marker} */ function createMarkerSeries(name, input, color) { /** Set marker series. * @see {@link https://api.anychart.com/7.14.3/anychart.charts.Map#marker} * @type {anychart.core.MAP.series.Marker} */ const series = MAP.marker(input).name(name); series.legendItem({ iconType: 'circle', iconFill: color, iconStroke: '2 #E1E1E1', }); const dimension = getDataDimension(); /** Set Tooltip for series */ series.tooltip() .useHtml(true) .padding([8, 13, 10, 13]) .title(false) .separator(false) .fontSize(14) .format(function () { if (dimension === 'trip') { return `&lt;span&gt;${this.getData('name')}&lt;/span&gt;&lt;br&gt;` + `&lt;span style=&quot;font-size: 12px; color: #E1E1E1&quot;&gt;Total trips: ${ parseInt(this.getData('size')).toLocaleString()}&lt;/span&gt;`; } return `&lt;span&gt;${this.getData('name')}&lt;/span&gt;`; }); /** Set styles for marker */ series.selectionMode('none') .stroke('2 #757575') .hoverStroke('3 #616161') .fill(color) .size(5) .labels(false) .hoverFill('#e74c3c') .hoverSize(8) .selectType('star7') .selectFill('#e74c3c') .selectSize(10) .type('circle'); series.id(name); series.listen('pointClick', (e) =&gt; { if (POINTCLICKED != null) { POINTCLICKED.selected(false); } POINTCLICKED = e.point; POINTCLICKED.selected(true); removeMapSeries('connector'); // MAP.zoomToFeature(POINTCLICKED.get('id')); toggleAnimation(true); }); } /** * Filter function to bind data to variables only within the range. * @param {number} start - The start range value. * @param {number} end - The end range value. * @returns {number} - The filtered result. */ function filterMarkerRange(start, end) { if (end) { return function (val) { return start &lt;= val &amp;&amp; val &lt; end; }; } return function (val) { return start &lt;= val; }; } /** * Generate a Connector coordinate from point A to point B * @param {anychart.core.SeriesPoint} pointA - Point A. * @param {anychart.core.SeriesPoint} pointB - Point B. * @see {@link https://api.anychart.com/7.14.3/anychart.core.SeriesPoint} * @returns {string} - A Connector coordinate in JSON. */ function getConnector(pointA, pointB) { /** get the choropleth series */ const series = MAP.getSeries('choropleth'); /** find regions with proper ids */ const pointIndex1 = series.data().find('id', pointA); const pointIndex2 = series.data().find('id', pointB); /** get the bounds of the first region */ const point1 = series.getPoint(pointIndex1); const bounds1 = point1.getFeatureBounds(); /** get the bounds of the second region */ const point2 = series.getPoint(pointIndex2); const bounds2 = point2.getFeatureBounds(); const half = 2; /** transformers pixel coordinates to latitude and longitude */ const latLong1 = MAP.inverseTransform(bounds1.left + bounds1.width / half, bounds1.top + bounds1.height / half); const latLong2 = MAP.inverseTransform(bounds2.left + bounds2.width / half, bounds2.top + bounds2.height / half); const floatPrecision = 7; /** return an array to be used in connector series */ return [parseFloat((latLong1.lat).toFixed(floatPrecision)), parseFloat((latLong1.long).toFixed(floatPrecision)), parseFloat((latLong2.lat).toFixed(floatPrecision)), parseFloat((latLong2.long).toFixed(floatPrecision)), ]; } /** * Remove a MAP series with its ID. * * @param {string} seriesId - The ID of targeted series. */ function removeMapSeries(seriesId) { if (MAP.getSeries(seriesId) != null) { MAP.removeSeries(seriesId); } } /** * Highlight the corresponding marker of the selected zone on the MAP. * * @param {string} zone - The marker that should be highlighted. * @param {boolean} zoom - Decide whether should zoom in onto the zone. */ function highlightPoint(zone, zoom) { if (POINTCLICKED != null) { if (POINTCLICKED.get('id') != zone.ZoneId) { POINTCLICKED.selected(false); } } const seriesId = zone.ZoneName; const targetSeries = MAP.getSeries(seriesId); const pointIndex = targetSeries.data().find('id', zone.ZoneId); if (POINTCLICKED != null) { if (POINTCLICKED.get('id') != zone.ZoneId) { POINTCLICKED = targetSeries.getPoint(pointIndex); POINTCLICKED.selected(true); if (zoom) { MAP.zoomToFeature(zone.ZoneId); } else { $('.anychart-zoom-zoomFitAll').click(); } } } else { POINTCLICKED = targetSeries.getPoint(pointIndex); POINTCLICKED.selected(true); if (zoom) { MAP.zoomToFeature(zone.ZoneId); } else { $('.anychart-zoom-zoomFitAll').click(); } } } /** * Highlight the the selected zone on the MAP. * * @param {string} zoneId - The ID of the zone that should be highlighted. */ function highlightZone(zoneId) { removeMapSeries('highlightZone'); const highlightZone = MAP.choropleth([{ id: zoneId, }]); highlightZone.id('highlightZone'); highlightZone.enabled(true); highlightZone.legendItem().enabled(false); MAP.zoomToFeature(zoneId); highlightZone.tooltip().enabled(false); } /** * Add a Connector series to the base MAP. * * @param {string} connectorData - The JSON data to be added to the base MAP as a Connector series. */ function addConnectorSeries(connectorData) { removeConnectorSeries(); jQuery.each(connectorData, (i, val) =&gt; { const connectorSeries = MAP.connector([val]); connectorSeries.id(`connector${i}`); connectorSeries.fill(val.color).hoverFill(val.color).stroke(val.color).hoverStroke(val.color); const weightMultiplier = 50; if (val.weight !== 0) { connectorSeries.endSize(val.weight * weightMultiplier + 1); } const markerSize = 20; const markerHoverSize = 25; connectorSeries.markers().position('95%').size(markerSize); connectorSeries.hoverMarkers().size(markerHoverSize); connectorSeries.tooltip().format(`${val.data} trips from ${val.from} to ${val.to}`); connectorSeries.legendItem().enabled(false); connectorSeries.listen('pointClick', () =&gt; { toggleAnimation(true); }); }); } /** * Remove all connector series on the base map. * */ function removeConnectorSeries() { for (let index = 0; index &lt; ZONE2; index++) { removeMapSeries(`connector${index}`); } } × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Smart Taxi Vis Modules HelperVis/ChordDiagramVis/HistogramVis/MapView Modules × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Smart Taxi Vis Modules HelperVis/ChordDiagramVis/HistogramVis/MapView Smart City VisualisationInteractive Data Visualisation for New York Taxi Operational Data Developed by Qiru Wang and submitted to Swansea University in partial fulﬁlment for the Degree of Master of Science. Supervised by Dr. Robert S. Laramee in Swansea University. Declaration This work has not previously been accepted in substance for any degree and is not being currently submitted for any degree. This dissertation is being submitted in partial fulﬁlment of the requirements for the degree of a MSc in Computer Science. This dissertation is the result of my own independent work/investigation, except where otherwise stated. Other sources are acknowledged by giving explicit references. A bibliography is appended. I hereby give consent for my dissertation to be available for photocopying and for inter-library loan, and for the title and summary to be made available to outside organisations. Data SourceNYC Taxi and Limousine Commission (TLC) Tools Used IDE Visual Studio Code Visual Studio 2017 Eclipse Third party library jQuery Bootsrap modernizr D3.js AnyChart noUiSlider wNumb pro4j Font Awesome Project management GitHub Taiga Database MySQL Documentation JSDoc DocStrap The above tools used are either open source, free to use or free for educational use. × Search results Close "},"module-Helper.html":{"id":"module-Helper.html","title":"Module: Helper","body":" Smart Taxi Vis Modules HelperVis/ChordDiagramVis/HistogramVis/MapView Module: Helper Author: Qiru Wang 689404@swansea.ac.uk Source: helper.js, line 1 Members &lt;inner&gt; DATA_HOLDER :string Store the current taxi zone data. Type: string Source: helper.js, line 123 &lt;inner&gt; HOURSLIDER :noUiSlider A noUiSlider for hours of the day. Type: noUiSlider Source: helper.js, line 88 See: https://refreshless.com/nouislider/ &lt;inner&gt; LASTLAYOUT Store the last Chord layout for next update. Source: helper.js, line 104 See: https://github.com/d3/d3-3.x-api-reference/blob/master/Chord-Layout.md#chord &lt;inner&gt; MAP Store an anymap instance. Source: helper.js, line 110 See: https://api.anychart.com/7.14.3/anychart.charts.Map &lt;inner&gt; POINTCLICKED :anychart.core.SeriesPoint The point that represents a taxizone, corresponding to the clicked path on Chord Diagram. Type: anychart.core.SeriesPoint Source: helper.js, line 97 See: https://api.anychart.com/7.14.3/anychart.core.SeriesPoint &lt;inner&gt; TIME1 :number Starting index of hours selected. Type: number Source: helper.js, line 66 &lt;inner&gt; TIME2 :number Starting index of hours selected. Type: number Source: helper.js, line 74 &lt;inner&gt; TOTALZONENUM :number Total number of taxi zones. Type: number Source: helper.js, line 48 &lt;inner&gt; ZONE1 :number Starting index of taxi zones selected. Type: number Source: helper.js, line 54 &lt;inner&gt; ZONE2 :number Ending index of taxi zones selected. Type: number Source: helper.js, line 60 &lt;inner&gt; ZONE_HOLDER :string Store the current taxi zones. Type: string Source: helper.js, line 116 &lt;inner&gt; ZONESLIDER :noUiSlider A noUiSlider for taxi zones. Type: noUiSlider Source: helper.js, line 81 See: https://refreshless.com/nouislider/ Methods &lt;inner&gt; generateColorForZone(zone, maxCount, minCount) Based on the largest and the smallest data count for all ZONE_HOLDER, generate a set of colors for ZONE_HOLDER on the Chord Diagram. Parameters: Name Type Description zone Array.&lt;string&gt; A matrix that contains input taxi ZONE_HOLDER. maxCount number The largest data count for all ZONE_HOLDER. minCount number The smallest data count for all ZONE_HOLDER. Source: helper.js, line 288 &lt;inner&gt; generateRainBowColorMap(count, max, min) → {string} Generate a rainbow color map based on the ratio of data count and the min/max data count. Parameters: Name Type Description count number Data count of one zone as the dividend. max number Max data count in the selected dataset. min number Min data count in the selected dataset. Source: helper.js, line 303 Returns: A HSL color. Type string &lt;inner&gt; getDataDimension() → {string} Return the current data dimension being visualised. Source: helper.js, line 182 Returns: The current data dimension being visualised. Type string &lt;inner&gt; getIndividualDataCount(data) → {Array.&lt;number&gt;} Calculate the given data count. Parameters: Name Type Description data string The input data count data in JSON. Source: helper.js, line 272 Returns: The total data count. Type Array.&lt;number&gt; &lt;inner&gt; getTotalDataCount(data) → {Array.&lt;number&gt;} Iterate the input matrix and sum up all count. Also calcualte the largest and the smallest values in the input data. Parameters: Name Type Description data Array.&lt;Array.&lt;number&gt;&gt; A matrix that contains the input data Source: helper.js, line 244 Returns: An array with total data count, the largest and the smallest values in the input data. Type Array.&lt;number&gt; &lt;inner&gt; initGlobalVariables() Initialise global variables needed for the application. Source: helper.js, line 41 &lt;inner&gt; initSliders() Initialise a noUiSlider for zones and hours. Source: helper.js, line 131 See: https://refreshless.com/nouislider/ &lt;inner&gt; setDataCountHTML(count) Update the data count for the HTML element. Parameters: Name Type Description count number The data count used. Source: helper.js, line 332 &lt;inner&gt; setHourHTML(hour) Update the hour for the HTML element. Parameters: Name Type Description hour number The hour used. Source: helper.js, line 323 &lt;inner&gt; spliceMatrix(matrix) → {Array.&lt;number&gt;|Array.&lt;string&gt;} Splice the input array based on the ZONE_HOLDER selected. Parameters: Name Type Description matrix Array.&lt;number&gt; | Array.&lt;string&gt; A matrix that contains the input data. Source: helper.js, line 199 Returns: The spliced array with the selected ZONE_HOLDER only. Type Array.&lt;number&gt; | Array.&lt;string&gt; &lt;inner&gt; spliceSubTripMatrix(matrix) → {Array.&lt;number&gt;} Splice the input nested array based on the ZONE_HOLDER selected, for data count matrix. Parameters: Name Type Description matrix Array.&lt;number&gt; A matrix that contains the input data. Source: helper.js, line 213 Returns: The spliced array with the selected ZONE_HOLDER only. Type Array.&lt;number&gt; &lt;inner&gt; toggleNoMatchMessage(toggle) Toggle the display of 'No Match' message, visulisations and controls. Parameters: Name Type Description toggle boolean If True: displays the message. Deprecated: since issue #12 Dynamic ranged colormap. Source: helper.js, line 226 × Search results Close "},"module-Vis_ChordDiagram.html":{"id":"module-Vis_ChordDiagram.html","title":"Module: Vis/ChordDiagram","body":" Smart Taxi Vis Modules HelperVis/ChordDiagramVis/HistogramVis/MapView Module: Vis/ChordDiagram Author: Qiru Wang 689404@swansea.ac.uk Source: chordDiagram.js, line 1 Requires module:Helper Methods &lt;inner&gt; animationSetData() Update hourSlider and HTML element 'Hour of the day' to the corresponding hour animated. Source: chordDiagram.js, line 118 &lt;inner&gt; calculateLabelRotation(input) Calculate the rotation angle for label of the chord. Parameters: Name Type Description input string Contains the JSON data for a chord Source: chordDiagram.js, line 442 Returns: The rotation and translation angles for the label. &lt;inner&gt; chordAnimation() Start the animation for Chord Diagram. Source: chordDiagram.js, line 98 &lt;inner&gt; formatChordTitle(chord, index) → {string} Format the text appeared when mouse hover the chord. Parameters: Name Type Description chord string A JSON string that contains the chord. index number The index of the taxi zone represented by the chord. Source: chordDiagram.js, line 310 Returns: The text appeared when mouse hover the chord. Type string &lt;inner&gt; formatJSON() Trigger all necessary functions when data is changed. E.g. Re-render Chord Diagram, Map Diagram and Histogram.Also update the visibility of some HTML elements. Source: chordDiagram.js, line 48 &lt;inner&gt; formatPathTitle(path, innerZone) → {string} Format the text appeared when mouse hover the path. Parameters: Name Type Description path string A JSON string that contains the source and the target chord of the path. innerZone boolean If the path if representing the inner zone trips. Source: chordDiagram.js, line 252 Returns: THe text appeared when mouse hover the path. Type string &lt;inner&gt; generateChordColorLegend() Generate a legend for Chord Diagram based on the color map used. Deprecated: since issue #13 Dynamically update zoneSlider's range. Source: chordDiagram.js, line 160 &lt;inner&gt; getDefaultLayout() → {d3.layout} Sort the Chord Diagram. Source: chordDiagram.js, line 148 See: https://github.com/d3/d3-3.x-api-reference/blob/master/Chord-Layout.md#chord Returns: The sorted D3 Chord Diagram layout. Type d3.layout &lt;inner&gt; highlightColormapLegend(low, high) Highlight the current range of colors used on the colormap legend. Also reset global variables: lowerColor and higherColor. Parameters: Name Type Description low number The hue of the color for the largest data value. high number The hud of the color for the smallest data value. Deprecated: since issue #12 Dynamic ranged colormap. Source: chordDiagram.js, line 70 &lt;inner&gt; initChordDiagram() Initialise a Chord Diagram. Source: chordDiagram.js, line 188 &lt;inner&gt; pathToConnector(source, target, value) Format the data from the clicked paht on Chord Diagram, and display the connector on Map. Parameters: Name Type Description source string The origination taxi zone. target string The destination taxi zone. value string The number of trips. Source: chordDiagram.js, line 456 &lt;inner&gt; toggleAnimation(pausing) Toggle the animation state based on the input boolean value. Parameters: Name Type Description pausing boolean The input boolean value. Source: chordDiagram.js, line 129 &lt;inner&gt; updateChordDiagram(matrix) Update the chords for Chord Diagram. Add event listeners, transition effects and many minor tweaks to Chord Diagram. Parameters: Name Type Description matrix Array.&lt;Array.&lt;number&gt;&gt; A matrix that contains the input data. Source: chordDiagram.js, line 338 × Search results Close "},"module-Vis_Histogram.html":{"id":"module-Vis_Histogram.html","title":"Module: Vis/Histogram","body":" Smart Taxi Vis Modules HelperVis/ChordDiagramVis/HistogramVis/MapView Module: Vis/Histogram Author: Qiru Wang 689404@swansea.ac.uk Source: histogram.js, line 1 Requires module:Helper Methods &lt;inner&gt; generateHistogram() Start generating histogram. Source: histogram.js, line 13 &lt;inner&gt; generateHourHistogramData() Generate data for Hour Histogram. Source: histogram.js, line 27 &lt;inner&gt; generateZoneHistogramData() Generate data for Zone Histogram. Source: histogram.js, line 57 &lt;inner&gt; renderHistogram(input, type) Render the Histogram with input data and type. Parameters: Name Type Description input Array.&lt;Array.&lt;any&gt;&gt; The input data for histogram. type string Type of the histogram to be rendered, either Zone or Hour. Source: histogram.js, line 75 × Search results Close "},"module-Vis_MapView.html":{"id":"module-Vis_MapView.html","title":"Module: Vis/MapView","body":" Smart Taxi Vis Modules HelperVis/ChordDiagramVis/HistogramVis/MapView Module: Vis/MapView Author: Qiru Wang 689404@swansea.ac.uk Source: mapDiagram.js, line 1 Requires module:Helper Methods &lt;inner&gt; addConnectorSeries(connectorData) Add a Connector series to the base MAP. Parameters: Name Type Description connectorData string The JSON data to be added to the base MAP as a Connector series. Source: mapDiagram.js, line 271 &lt;inner&gt; createMarkerSeries(name, input, color) Create a marker series. Parameters: Name Type Description name string Name of the marker series. input any Data of the marker series. color string Color of the marker series. Source: mapDiagram.js, line 91 See: https://api.anychart.com/7.14.3/anychart.charts.Map#marker &lt;inner&gt; filterMarkerRange(start, end) → {number} Filter function to bind data to variables only within the range. Parameters: Name Type Description start number The start range value. end number The end range value. Source: mapDiagram.js, line 153 Returns: The filtered result. Type number &lt;inner&gt; generateMap() Render a Choropleth MAP as base series, add Marker series on top of the base series. Source: mapDiagram.js, line 17 &lt;inner&gt; getConnector(pointA, pointB) → {string} Generate a Connector coordinate from point A to point B Parameters: Name Type Description pointA anychart.core.SeriesPoint Point A. pointB anychart.core.SeriesPoint Point B. Source: mapDiagram.js, line 171 See: https://api.anychart.com/7.14.3/anychart.core.SeriesPoint Returns: A Connector coordinate in JSON. Type string &lt;inner&gt; highlightPoint(zone, zoom) Highlight the corresponding marker of the selected zone on the MAP. Parameters: Name Type Description zone string The marker that should be highlighted. zoom boolean Decide whether should zoom in onto the zone. Source: mapDiagram.js, line 218 &lt;inner&gt; highlightZone(zoneId) Highlight the the selected zone on the MAP. Parameters: Name Type Description zoneId string The ID of the zone that should be highlighted. Source: mapDiagram.js, line 254 &lt;inner&gt; removeConnectorSeries() Remove all connector series on the base map. Source: mapDiagram.js, line 302 &lt;inner&gt; removeMapSeries(seriesId) Remove a MAP series with its ID. Parameters: Name Type Description seriesId string The ID of targeted series. Source: mapDiagram.js, line 205 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
