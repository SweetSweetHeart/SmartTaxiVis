<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>Smart City Vis Documentation Source: chordDiagram.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.flatly.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top ">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">Smart City Vis Documentation</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="modules.list.html" class="dropdown-toggle" data-toggle="dropdown">Modules<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="module-ChordDiagram.html">ChordDiagram</a></li><li><a href="module-Initialisation.html">Initialisation</a></li><li><a href="module-Map.html">Map</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: chordDiagram.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript linenums">﻿/**
 * @author Qiru Wang &lt;689404@swansea.ac.uk>
 * 
 */

/**
 * @module ChordDiagram
 */

/**
 * Start the animation for Chord Diagram.
 * 
 */
function chordAnimation() {
    isPaused = false;
    interval = setInterval(function () {
        if (!isPaused) {
            time1++;
            if (time1 > 23)
                time1 = 0;
            animationSetData();
        }
    }, 3000);
}


/**
 * Update variables zoneMatrix and zoneMatrix, and HTML element 'Hour of the day' to the corresponding hour animated.
 * 
 */
function animationSetData() {
    zoneMatrix = zoneT[time1];
    tripMatrix = countT[time1];
    hourSlider.noUiSlider.set(time1);
    $("#hour").html(time1);
    formatJSON();
}


/**
 * Toggle the animation state based on the input boolean value.
 * @param {boolean} pausing - The input boolean value.
 */
function toggleAnimation(pausing) {
    if (pausing) {
        isPaused = true;
        $('#btn_pause').html("&lt;i class='fa fa-play' aria-hidden='true'>&lt;/i>&amp;nbsp;&amp;nbsp;Animation");
    } else {
        if (!isPaused) {
            isPaused = true;
            $('#btn_pause').html("&lt;i class='fa fa-play' aria-hidden='true'>&lt;/i>&amp;nbsp;&amp;nbsp;Animation");
        } else {
            isPaused = false;
            $('#btn_pause').html("&lt;i class='fa fa-pause' aria-hidden='true'>&lt;/i>&amp;nbsp;&amp;nbsp;Animation");
        }
    }
}


/**
 * Sort the Chord Diagram.
 * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Chord-Layout.md#chord}
 * @returns {d3.layout} - The sorted D3 Chord Diagram layout.
 */
function getDefaultLayout() {
    return d3.layout.chord()
        .padding(0.03)
        .sortSubgroups(d3.descending)
        .sortChords(d3.ascending);
}


/**
 * Calculate the given trip count.
 * 
 * @param {string} data - The input trip count data in JSON.
 * @returns {number} - The total trip count.
 */
function getTripCount(data) {
    var result = 0;
    jQuery.each(data, function (i, val) {
        jQuery.each(val, function (j, val2) {
            result += parseInt(val2);
        });
    });
    return result;
}


/**
 * Generate a rainbow color map based on the ratio of trips and the total trip count.
 * 
 * @param {number} length  - Trip count of one zone as the dividend.
 * @param {number} maxLength - Total trip count of all zones as the divisor.
 * @returns - A rgb color.
 */
function generateRainBowColorMap(length, maxLength) {
    var i = (length * 550 / maxLength);
    var r = Math.round(Math.sin(0.024 * i + 0) * 127 + 128);
    var g = Math.round(Math.sin(0.024 * i + 2) * 127 + 128);
    var b = Math.round(Math.sin(0.024 * i + 4) * 127 + 128);
    return 'rgb(' + r + ',' + g + ',' + b + ')';
}

/**
 * Trigger all necessary functions when data is changed. E.g. Re-render Chord Diagram, Map Diagram and Histogram.
 * Also update the visibility of some HTML elements.
 */
function formatJSON() {
    var trips = $.extend(true, [], tripMatrix);
    zones = $.extend(true, [], zoneMatrix);
    spliceMatrix(zones);
    spliceMatrix(trips);
    spliceSubMatrix(trips);

    tripCount = getTripCount(trips);
    // Assign random colors to chords
    jQuery.each(zones, function (i, val) {
        val.color = generateRainBowColorMap(val.Pickup, tripCount);
    });

    $("#tripCount").html(tripCount);


    dataSet = anychart.data.set(zones);

    connectorData = null;
    generateHistogramData();

    if (tripCount > 0) {
        $("#chordDiagram:hidden").show();
        $("#anymap:hidden").show();
        $("#nomatch:visible").hide();
        renderMap();
        updateChordDiagram(trips);
    } else {
        $("#chordDiagram:visible").hide();
        $("#anymap:visible").hide();
        $("#nomatch:hidden").show();
    }
}



/**
 * Splice the input array based on the zones selected.
 * 
 * @param {number[]|string[]} matrix - The input array with all zones.
 * @returns {number[]|string[]} - The spliced array with the selected zones only.
 */
function spliceMatrix(matrix) {
    matrix.splice(0, zone1);
    matrix.splice(zone2 - zone1 + 1, totalZoneNum - zone2);
    return matrix;
}

/**
 * Splice the input nested array based on the zones selected, for trip count matrix.
 * 
 * @param {number[]} matrix 
 * @returns  {number[]} - The spliced array with the selected zones only.
 */

function spliceSubMatrix(matrix) {
    matrix.forEach(function (element, i) {
        spliceMatrix(element);
    }, this);
    return matrix;
}

/**
 * Initialise a Chrod Diagram.
 * 
 */
function initChordDiagram() {
    // Reformat the trip matrix when conditions changes, and update related visualisations

    var targetSize = $("#chordDiagram").width() * .85;
    var marginSide = $("#chordDiagram").width() * .075;

    $(window).resize(function () {
        var svg = d3.select("#chordDiagram")
            .attr("width", targetSize)
            .attr("height", targetSize);

        outerRadius = Math.min(targetSize, targetSize) / 2 - 50,
            innerRadius = outerRadius - 18;

        arc = d3.svg.arc()
            .innerRadius(innerRadius)
            .outerRadius(outerRadius);

        path = d3.svg.chord()
            .radius(innerRadius);

        $('#circle').attr("r", outerRadius);
        $('[data-toggle="popover"]').popover('show');

    });

    outerRadius = Math.min(targetSize, targetSize) / 2 - 50,
        innerRadius = outerRadius - 18;

    viewBoxDimensions = "0 0 " + targetSize + " " + targetSize;

    // Create the arc path data generator for the groups
    arc = d3.svg.arc()
        .innerRadius(innerRadius)
        .outerRadius(outerRadius);

    // Create the chord path data generator for the chords
    path = d3.svg.chord()
        .radius(innerRadius);

    var last_layout; // store layout between updates

    // Create number formatting functions
    var formatPercent = d3.format("%");
    numberWithCommas = d3.format("0,f");

    // Initialize the visualization
    g = d3.select("#chordDiagram").append("svg")
        .attr("viewBox", viewBoxDimensions)
        .attr("preserveAspectRatio", "xMinYMid")
        .append("g")
        .attr("id", "circle")
        .attr("overflow-x", "visible")
        .attr("transform",
            "translate(" + targetSize / 2 + "," + targetSize / 2 + ")");

    g.append("circle")
        .attr("r", outerRadius);
}

/**
 * Update the chords for Chord Diagram. Add event listeners, transition effects and many minor tweaks to Chord Diagram.
 * 
 * @param {number[]} matrix - The input data matrix of trips
 */
function updateChordDiagram(matrix) {
    // Remove empty svg generated by animation loop.
    $("svg[width=0]").remove();

    layout = getDefaultLayout();
    layout.matrix(matrix);

    // Create/update "group" elements
    var groupG = g.selectAll("g.group")
        .data(layout.groups(), function (d) {
            return d.index;
            //use a key function in case the
            //groups are sorted differently between updates
        });

    groupG.exit()
        .transition()
        .duration(800)
        .attr("opacity", 0.5)
        .remove(); // Remove after transitions are complete

    var newGroups = groupG.enter().append("g")
        .attr("class", "group");
    // The enter selection is stored in a variable so we can
    // Enter the &lt;path>, &lt;text>, and &lt;title> elements as well

    // Create the title tooltip for the new groups
    newGroups.append("title");

    // Update the (tooltip) title text based on the data
    groupG.select("title")
        .text(function (d, i) {
            return numberWithCommas(d.value) +
                " trips started in " +
                zones[i].name;
        });

    // create the arc paths and set the constant attributes
    // (those based on the group index, not on the value)
    newGroups.append("path")
        .attr("id", function (d) {
            return "group" + d.index;
        })
        .style("fill", function (d) {
            return zones[d.index].color;
        });

    // Update the paths to match the layout and color
    groupG.select("path")
        .transition()
        .duration(800)
        .attr("opacity", 0.5)
        .attr("d", arc)
        .style("fill", function (d) {
            return zones[d.index].color;
        })
        .transition().duration(10).attr("opacity", 1) //reset opacity
    ;

    newGroups.append("svg:text")
        .attr("xlink:href", function (d) {
            return "#group" + d.index;
        })
        .attr("dy", ".35em")
        .attr("color", "#fff")
        .text(function (d) {
            return zones[d.index].name;
        });

    // Position group labels to match layout
    groupG.select("text")
        .transition()
        .duration(800)
        .text(function (d) {
            return zones[d.index].name;
        })
        .attr("transform", function (d) {
            d.angle = (d.startAngle + d.endAngle) / 2;
            // Store the midpoint angle in the data object

            return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")" +
                " translate(" + (innerRadius + 26) + ")" +
                (d.angle > Math.PI ? " rotate(180)" : " rotate(0)");
            // Include the rotate zero so that transforms can be interpolated
        })
        .attr("text-anchor", function (d) {
            return d.angle > Math.PI ? "end" : "begin";
        });

    var chordPaths = g.selectAll("path.chord")
        .data(layout.chords(), chordKey);

    var newChords = chordPaths.enter()
        .append("path")
        .attr("class", "chord");

    newChords.append("title");

    chordPaths.select("title")
        .text(function (d) {
            if (zones[d.target.index].name !== zones[d.source.index].name) {
                return [numberWithCommas(d.source.value),
                    " trips from ",
                    zones[d.source.index].name,
                    " to ",
                    zones[d.target.index].name,
                    "\n",
                    numberWithCommas(d.target.value),
                    " trips from ",
                    zones[d.target.index].name,
                    " to ",
                    zones[d.source.index].name
                ].join("");
            } else {
                return numberWithCommas(d.source.value) +
                    " trips started and ended in " +
                    zones[d.source.index].name;
            }
        });

    chordPaths.exit().transition()
        .duration(800)
        .attr("opacity", 0)
        .remove();

    chordPaths.transition()
        .duration(800)
        .attr("opacity", 0.5)
        .style("fill", function (d) {
            return zones[d.source.index].color;
        })
        .attr("d", path)
        .transition().duration(10).attr("opacity", 1);

    groupG.on("mouseover", function (d) {
        toggleAnimation(true);
        chordPaths.classed("fade", function (p) {
            return ((p.source.index != d.index) &amp;&amp; (p.target.index != d.index));
        });
    });

    chordPaths.on("mouseover", function (d) {
        toggleAnimation(true);
        chordPaths.attr("opacity", 0.2);
        $(this).attr("opacity", 1);
    });


    chordPaths.on("click", function (d) {
        var pointData = getConnector(zones[d.source.index].id, zones[d.target.index].id);
        if (zones[d.source.index].id != zones[d.target.index].id) {
            connectorData = [{
                points: pointData,
                from: zones[d.source.index].name,
                to: zones[d.target.index].name
            }];
            addConnectorSeries(connectorData);
            highlightPoint(zones[d.source.index]);
        } else {
            removeMapSeries('connector');
            highlightPoint(zones[d.source.index]);
        }

        toggleAnimation(true);

    });

    chordPaths.on("mouseout", function () {
        chordPaths.attr("opacity", 0.5);
        //toggleAnimation(false);
    });

    g.on("mouseout", function () {
        if (this == g.node()) {
            // Only respond to mouseout of the entire circle not mouseout events for sub-components
            chordPaths.classed("fade", false);
        }
    });
    last_layout = layout;
}

function arcTween(oldLayout) {
    var oldGroups = {};
    if (oldLayout) {
        oldLayout.groups().forEach(function (groupData) {
            oldGroups[groupData.index] = groupData;
        });
    }
    return function (d, i) {
        var tween;
        var old = oldGroups[d.index];
        if (old) { // There's a matching old group
            tween = d3.interpolate(old, d);
        } else {
            // Create a zero- width arc object
            var emptyArc = {
                startAngle: d.startAngle,
                endAngle: d.startAngle
            };
            tween = d3.interpolate(emptyArc, d);
        }
        return function (t) {
            return arc(tween(t));
        };
    };
}

function chordKey(data) {
    return (data.source.index &lt; data.target.index) ?
        data.source.index + "-" + data.target.index :
        data.target.index + "-" + data.source.index;
}

function chordTween(oldLayout) {
    var oldChords = {};
    if (oldLayout) {
        oldLayout.chords().forEach(function (chordData) {
            oldChords[chordKey(chordData)] = chordData;
        });
    }

    return function (d, i) {
        var tween;
        var old = oldChords[chordKey(d)];
        if (old) {
            if (d.source.index != old.source.index) {
                old = {
                    source: old.target,
                    target: old.source
                };
            }

            tween = d3.interpolate(old, d);
        } else {
            // Create a zero- width chord object
            var emptyChord = {
                source: {
                    startAngle: d.source.startAngle,
                    endAngle: d.source.startAngle
                },
                target: {
                    startAngle: d.target.startAngle,
                    endAngle: d.target.startAngle
                }
            };
            tween = d3.interpolate(emptyChord, d);
        }
        return function (t) {
            return path(tween(t));
        };
    };
}</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


	<span class="copyright">
	Qiru Wang © 2017 
	</span>

<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.4</a>
	
		on Thu Aug 10th 2017
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>
