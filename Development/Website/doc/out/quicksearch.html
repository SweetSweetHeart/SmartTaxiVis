<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"chordDiagram.js.html":{"id":"chordDiagram.js.html","title":"Source: chordDiagram.js","body":" Smart City Vis Home ChordDiagramHistogramInitialisationMapView Source: chordDiagram.js /** * @author Qiru Wang 689404@swansea.ac.uk * * @module ChordDiagram */ /** * Start the animation for Chord Diagram. * */ function chordAnimation() { isPaused = false; interval = setInterval(function () { if (!isPaused) { time1++; if (time1 &gt; 23) time1 = 0; animationSetData(); } }, 3000); } /** * Update variables zoneMatrix and zoneMatrix, and HTML element 'Hour of the day' to the corresponding hour animated. * */ function animationSetData() { zoneMatrix = zoneT[time1]; tripMatrix = countT[time1]; hourSlider.noUiSlider.set(time1); $(&quot;#hour&quot;).html(time1); formatJSON(); } /** * Toggle the animation state based on the input boolean value. * @param {boolean} pausing - The input boolean value. */ function toggleAnimation(pausing) { if (pausing) { isPaused = true; $('#btn_pause').html(&quot;&lt;i class='fa fa-play' aria-hidden='true'&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;Animation&quot;); } else { if (!isPaused) { isPaused = true; $('#btn_pause').html(&quot;&lt;i class='fa fa-play' aria-hidden='true'&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;Animation&quot;); } else { isPaused = false; $('#btn_pause').html(&quot;&lt;i class='fa fa-pause' aria-hidden='true'&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;Animation&quot;); } } } /** * Sort the Chord Diagram. * @see {@link https://github.com/d3/d3-3.x-api-reference/blob/master/Chord-Layout.md#chord} * @returns {d3.layout} - The sorted D3 Chord Diagram layout. */ function getDefaultLayout() { return d3.layout.chord() .padding(0.03) .sortSubgroups(d3.descending) .sortChords(d3.ascending); } /** * Calculate the given trip count. * * @param {string} data - The input trip count data in JSON. * @returns {number} - The total trip count. */ function getTripCount(data) { var result = 0; jQuery.each(data, function (i, val) { result += parseInt(val); }); return result; } /** * Generate a rainbow color map based on the ratio of trips and the total trip count. * * @param {number} trips - Trip count of one zone as the dividend. * @param {number} totalTrips - Total trip count of all zones as the divisor. * @returns - A rgb color. */ function generateRainBowColorMap(trips, totalTrips) { var i = Math.round(200 - Math.abs(1 - (trips * 800 / totalTrips))); chordLegendColor.push(i); return 'hsl(' + i + ',83%,50%)'; } /** * Generate a legend for Chord Diagram based on the color map used. * */ function generateChordColorLegend() { $(&quot;#chordColorLegend&quot;).empty(); $(&quot;#chordColorLegend&quot;).append(&quot;Legend: &amp;nbsp; &amp;nbsp; &amp;nbsp; Max &quot;); chordLegendColor = Array.from(new Set(chordLegendColor)); chordLegendColor.sort(function (a, b) { return a - b; }); var last; jQuery.each(chordLegendColor, function (i, val) { if ((last == null) || (last != null &amp;&amp; val &gt; (last + 3))) $(&quot;#chordColorLegend&quot;).append(&quot;&lt;font style=color:hsl(&quot; + val + &quot;,83%,50%)&gt;█&lt;/font&gt;&quot;); last = val; }); $(&quot;#chordColorLegend&quot;).append(&quot; Min&quot;); chordLegendColor = []; } /** * Trigger all necessary functions when data is changed. E.g. Re-render Chord Diagram, Map Diagram and Histogram. * Also update the visibility of some HTML elements. */ function formatJSON() { trips = $.extend(true, [], tripMatrix); zones = $.extend(true, [], zoneMatrix); spliceMatrix(zones); spliceMatrix(trips); spliceSubMatrix(trips); var tripCount = 0; jQuery.each(trips, function (i, val) { tripCount += getTripCount(val); }); // Assign random colors to chords jQuery.each(zones, function (i, val) { val.color = generateRainBowColorMap(val.Pickup, tripCount); }); generateChordColorLegend(); generateHistogram(); $(&quot;#tripCount&quot;).html(tripCount); dataSet = anychart.data.set(zones); connectorData = null; if (tripCount &gt; 0) { toggleNoMatchMessage(false); renderMap(); updateChordDiagram(trips); } else { toggleNoMatchMessage(true); } } /** * Toggle the display of 'No Match' message, visulisations and controls. * * @param {boolean} toggle - If True: displays the message. */ function toggleNoMatchMessage(toggle) { if (!toggle) { $(&quot;.visualisationRow:hidden&quot;).show(); $(&quot;.controlRow:hidden&quot;).show(); $(&quot;#nomatch:visible&quot;).hide(); } else { $(&quot;.visualisationRow:visible&quot;).hide(); $(&quot;.controlRow:visible&quot;).hide(); $(&quot;#nomatch:hidden&quot;).show(); } } /** * Splice the input array based on the zones selected. * * @param {number[]|string[]} matrix - The input array with all zones. * @returns {number[]|string[]} - The spliced array with the selected zones only. */ function spliceMatrix(matrix) { matrix.splice(0, zone1); matrix.splice(zone2 - zone1 + 1, totalZoneNum - zone2); return matrix; } /** * Splice the input nested array based on the zones selected, for trip count matrix. * * @param {number[]} matrix * @returns {number[]} - The spliced array with the selected zones only. */ function spliceSubMatrix(matrix) { jQuery.each(matrix, function (i, val) { spliceMatrix(val); }); return matrix; } /** * Initialise a Chord Diagram. * */ function initChordDiagram() { var targetSize = $(&quot;#chordDiagram&quot;).width() * .85; var marginSide = $(&quot;#chordDiagram&quot;).width() * .075; $(window).resize(function () { var svg = d3.select(&quot;#chordDiagram&quot;) .attr(&quot;width&quot;, targetSize) .attr(&quot;height&quot;, targetSize); outerRadius = Math.min(targetSize, targetSize) / 2 - 50; innerRadius = outerRadius - 18; arc = d3.svg.arc() .innerRadius(innerRadius) .outerRadius(outerRadius); path = d3.svg.chord() .radius(innerRadius); $('#circle').attr(&quot;r&quot;, outerRadius); $('[data-toggle=&quot;popover&quot;]').popover('show'); }); outerRadius = Math.min(targetSize, targetSize) / 2 - 50; innerRadius = outerRadius - 18; viewBoxDimensions = &quot;0 0 &quot; + targetSize + &quot; &quot; + targetSize; // Create the arc path data generator for the groups arc = d3.svg.arc() .innerRadius(innerRadius) .outerRadius(outerRadius); // Create the chord path data generator for the chords path = d3.svg.chord() .radius(innerRadius); lastLayout = getDefaultLayout(); // store layout between updates // Create number formatting functions var formatPercent = d3.format(&quot;%&quot;); numberWithCommas = d3.format(&quot;0,f&quot;); // Initialize the visualization g = d3.select(&quot;#chordDiagram&quot;).append(&quot;svg&quot;) .attr(&quot;viewBox&quot;, viewBoxDimensions) .attr(&quot;preserveAspectRatio&quot;, &quot;xMinYMid&quot;) .append(&quot;g&quot;) .attr(&quot;id&quot;, &quot;circle&quot;) .attr(&quot;overflow-x&quot;, &quot;visible&quot;) .attr(&quot;transform&quot;, &quot;translate(&quot; + targetSize / 2 + &quot;,&quot; + targetSize / 2 + &quot;)&quot;); g.append(&quot;circle&quot;) .attr(&quot;r&quot;, outerRadius); } /** * Update the chords for Chord Diagram. Add event listeners, transition effects and many minor tweaks to Chord Diagram. * * @param {Array.&lt;number[]&gt;} matrix - The input data matrix of trips */ function updateChordDiagram(matrix) { // Remove empty svg generated by animation loop. $(&quot;svg[width=0]&quot;).remove(); layout = getDefaultLayout(); layout.matrix(matrix); // Create/update &quot;group&quot; elements var groupG = g.selectAll(&quot;g.group&quot;) .data(layout.groups(), function (d) { return d.index; //use a key function in case the //groups are sorted differently between updates }); groupG.exit() .transition() .duration(800) .attr(&quot;opacity&quot;, 0.5) .remove(); // Remove after transitions are complete var newGroups = groupG.enter().append(&quot;g&quot;) .attr(&quot;class&quot;, &quot;group&quot;); // The enter selection is stored in a variable so we can // Enter the &lt;path&gt;, &lt;text&gt;, and &lt;title&gt; elements as well // Create the title tooltip for the new groups newGroups.append(&quot;title&quot;); // Update the (tooltip) title text based on the data groupG.select(&quot;title&quot;) .text(function (d, i) { return numberWithCommas(d.value) + &quot; trips started in &quot; + zones[i].name; }); // create the arc paths and set the constant attributes // (those based on the group index, not on the value) newGroups.append(&quot;path&quot;) .attr(&quot;id&quot;, function (d) { return &quot;group&quot; + d.index; }) .style(&quot;fill&quot;, function (d) { return zones[d.index].color; }); // Update the paths to match the layout and color groupG.select(&quot;path&quot;) .transition() .duration(800) .attr(&quot;opacity&quot;, 0.5) .attr(&quot;d&quot;, arc) .attrTween(&quot;d&quot;, arcTween(lastLayout)) .style(&quot;fill&quot;, function (d) { return zones[d.index].color; }) .transition().duration(10).attr(&quot;opacity&quot;, 1) //reset opacity ; newGroups.append(&quot;svg:text&quot;) .attr(&quot;xlink:href&quot;, function (d) { return &quot;#group&quot; + d.index; }) .attr(&quot;dy&quot;, &quot;.35em&quot;) .attr(&quot;color&quot;, &quot;#fff&quot;) .text(function (d) { return zones[d.index].name; }); // Position group labels to match layout groupG.select(&quot;text&quot;) .transition() .duration(800) .text(function (d) { return zones[d.index].name; }) .attr(&quot;transform&quot;, function (d) { d.angle = (d.startAngle + d.endAngle) / 2; // Store the midpoint angle in the data object return &quot;rotate(&quot; + (d.angle * 180 / Math.PI - 90) + &quot;)&quot; + &quot; translate(&quot; + (innerRadius + 26) + &quot;)&quot; + (d.angle &gt; Math.PI ? &quot; rotate(180)&quot; : &quot; rotate(0)&quot;); // Include the rotate zero so that transforms can be interpolated }) .attr(&quot;text-anchor&quot;, function (d) { return d.angle &gt; Math.PI ? &quot;end&quot; : &quot;begin&quot;; }); var chordPaths = g.selectAll(&quot;path.chord&quot;) .data(layout.chords(), chordKey); var newChords = chordPaths.enter() .append(&quot;path&quot;) .attr(&quot;class&quot;, &quot;chord&quot;); newChords.append(&quot;title&quot;); chordPaths.select(&quot;title&quot;) .text(function (d) { if (zones[d.target.index].name !== zones[d.source.index].name) { return [numberWithCommas(d.source.value), &quot; trips from &quot;, zones[d.source.index].name, &quot; to &quot;, zones[d.target.index].name, &quot;\\n&quot;, numberWithCommas(d.target.value), &quot; trips from &quot;, zones[d.target.index].name, &quot; to &quot;, zones[d.source.index].name ].join(&quot;&quot;); } else { return numberWithCommas(d.source.value) + &quot; trips started and ended in &quot; + zones[d.source.index].name; } }); chordPaths.exit().transition() .duration(800) .attr(&quot;opacity&quot;, 0) .remove(); chordPaths.transition() .duration(800) .attr(&quot;opacity&quot;, 0.5) .style(&quot;fill&quot;, function (d) { return zones[d.source.index].color; }) .attrTween(&quot;d&quot;, chordTween(lastLayout)) .attr(&quot;d&quot;, path) .transition().duration(10).attr(&quot;opacity&quot;, 1); groupG.on(&quot;mouseover&quot;, function (d) { toggleAnimation(true); chordPaths.classed(&quot;fade&quot;, function (p) { return ((p.source.index != d.index) &amp;&amp; (p.target.index != d.index)); }); }); chordPaths.on(&quot;mouseover&quot;, function (d) { toggleAnimation(true); chordPaths.attr(&quot;opacity&quot;, 0.2); $(this).attr(&quot;opacity&quot;, 1); }); chordPaths.on(&quot;click&quot;, function (d) { var pointData = getConnector(zones[d.source.index].id, zones[d.target.index].id); if (zones[d.source.index].id != zones[d.target.index].id) { connectorData = [{ points: pointData, from: zones[d.source.index].name, to: zones[d.target.index].name }]; addConnectorSeries(connectorData); highlightPoint(zones[d.source.index]); } else { removeMapSeries('connector'); highlightPoint(zones[d.source.index]); } toggleAnimation(true); }); chordPaths.on(&quot;mouseout&quot;, function () { chordPaths.attr(&quot;opacity&quot;, 0.5); //toggleAnimation(false); }); g.on(&quot;mouseout&quot;, function () { if (this == g.node()) { // Only respond to mouseout of the entire circle not mouseout events for sub-components chordPaths.classed(&quot;fade&quot;, false); } }); lastLayout = layout; } function arcTween(oldLayout) { var oldGroups = {}; if (oldLayout) { oldLayout.groups().forEach(function (groupData) { oldGroups[groupData.index] = groupData; }); } return function (d, i) { var tween; var old = oldGroups[d.index]; if (old) { // There's a matching old group tween = d3.interpolate(old, d); } else { // Create a zero- width arc object var emptyArc = { startAngle: d.startAngle, endAngle: d.startAngle }; tween = d3.interpolate(emptyArc, d); } return function (t) { return arc(tween(t)); }; }; } function chordKey(data) { return (data.source.index &lt; data.target.index) ? data.source.index + &quot;-&quot; + data.target.index : data.target.index + &quot;-&quot; + data.source.index; } function chordTween(oldLayout) { var oldChords = {}; if (oldLayout) { oldLayout.chords().forEach(function (chordData) { oldChords[chordKey(chordData)] = chordData; }); } return function (d, i) { var tween; var old = oldChords[chordKey(d)]; if (old) { if (d.source.index != old.source.index) { old = { source: old.target, target: old.source }; } tween = d3.interpolate(old, d); } else { // Create a zero- width chord object var emptyChord = { source: { startAngle: d.source.startAngle, endAngle: d.source.startAngle }, target: { startAngle: d.target.startAngle, endAngle: d.target.startAngle } }; tween = d3.interpolate(emptyChord, d); } return function (t) { return path(tween(t)); }; }; } × Search results Close "},"histogram.js.html":{"id":"histogram.js.html","title":"Source: histogram.js","body":" Smart City Vis Home ChordDiagramHistogramInitialisationMapView Source: histogram.js /** * @author Qiru Wang 689404@swansea.ac.uk * * @module Histogram */ /** * Start generating histogram. * */ function generateHistogram() { if ($(&quot;#histogramZone&quot;).is(&quot;:checked&quot;)) generateHistogramDataZone() else if ($(&quot;#histogramHour&quot;).is(&quot;:checked&quot;)) generateHistogramDataHour(); } /** * Generate data for Hour Histogram. * */ function generateHistogramDataHour() { var histogramData = []; for (var i = 0; i &lt; countT.length; i++) { var trips = $.extend(true, [], countT[i]); spliceMatrix(trips); spliceSubMatrix(trips); var tripCount = 0; jQuery.each(trips, function (i, val) { tripCount += getTripCount(val); }); if (i == time1) { histogramData.push([i.toString(), tripCount, &quot;#e74c3c&quot;]); } else histogramData.push([i.toString(), tripCount]); } renderHistogram(histogramData, &quot;hour&quot;); } /** * Generate data for Zone Histogram. * */ function generateHistogramDataZone() { var histogramData = []; var trips = $.extend(true, [], zoneMatrix); spliceMatrix(trips); jQuery.each(trips, function (i, val) { histogramData.push([val.name, val.Pickup]); }); renderHistogram(histogramData, &quot;zone&quot;); } /** * * * @param {Array.&lt;any[]&gt;} input - The input data for histogram. * @param {string} type - Type of the histogram generate, either Zone or Hour. */ function renderHistogram(input, type) { $('#histogram').empty(); var data = anychart.data.set(input); // create a chart histogramChart = anychart.column(); // create a column series and set the data var dataMap = data.mapAs({ x: [0], value: [1], fill: [2] }); var series = histogramChart.column(dataMap); series.tooltip() .useHtml(true) .title(false) .separator(false) .fontSize(14) .format(function () { if (type == &quot;hour&quot;) return &quot;&lt;span&gt;Taxizone: &quot; + this.getData('x') + &quot; to &quot; + (parseInt(this.getData('x')) + 1) + &quot; &lt;br/&gt;&quot; + &quot;Trips: &quot; + this.getData('value') + '&lt;/span&gt;'; else return &quot;&lt;span&gt;Taxizone: &quot; + this.getData('x') + &quot; &lt;br/&gt;&quot; + &quot;Trips: &quot; + this.getData('value') + '&lt;/span&gt;'; }); if (type == &quot;hour&quot;) { var xAxis = histogramChart.xAxis().title(&quot;Hour&quot;) histogramChart.listen(&quot;pointClick&quot;, function (e) { time1 = e.pointIndex; animationSetData(); toggleAnimation(true); }); } else { var xAxis = histogramChart.xAxis().title(&quot;Zone&quot;) } var yAxis = histogramChart.yAxis().title(&quot;Trips&quot;).orientation('right'); histogramChart.contextMenu(false); histogramChart.barGroupsPadding(0); histogramChart.container(&quot;histogram&quot;).draw(); }; × Search results Close "},"init.js.html":{"id":"init.js.html","title":"Source: init.js","body":" Smart City Vis Home ChordDiagramHistogramInitialisationMapView Source: init.js /** * @author Qiru Wang 689404@swansea.ac.uk * * @module Initialisation */ /** * Initialise a noUiSlider for zones and hours. * @see {@link https://refreshless.com/nouislider/} */ function initSliders() { noUiSlider.create(zoneSlider, { tooltips: true, format: wNumb({ decimals: 0 }), start: [1, zone2], step: 1, behaviour: 'drag-tap', connect: true, range: { 'min': 1, 'max': totalZoneNum } }); zoneSlider.noUiSlider.on('change', function (values) { zone1 = parseInt(values[0]); zone2 = parseInt(values[1]); toggleAnimation(true); formatJSON(); }); noUiSlider.create(hourSlider, { tooltips: true, animate: true, format: wNumb({ decimals: 0 }), start: time1, step: 1, range: { 'min': [0], 'max': [23] } }); hourSlider.noUiSlider.on('change', function (values) { time1 = parseInt(values[0]); animationSetData(); toggleAnimation(true); formatJSON(); }); }; /** * Initialise global variables needed for the application. * */ function initGlobalVariables() { // Some global variables needed. /** * Total number of taxizones. * @type {number} */ totalZoneNum = 263; /** * Starting index of taxizones selected. * @type {number} */ zone1 = 1; /** * Ending index of taxizones selected. * @type {number} */ zone2 = 20; /** * Starting index of hours selected. * @type {number} */ time1 = 9; /** * Starting index of hours selected. * @type {number} */ time2 = 15; /** * A noUiSlider for taxizones. * @type {noUiSlider} * @see {@link https://refreshless.com/nouislider/} */ zoneSlider = document.getElementById('zoneSlider'); /** * A noUiSlider for hours of the day. * @type {noUiSlider} * @see {@link https://refreshless.com/nouislider/} */ hourSlider = document.getElementById('hourSlider'); // Some default values to play with, before the server returns actual data /** * Trip count matrix of the selected hour. * @type {Array.&lt;number[]&gt;} */ tripMatrix = countT[time1]; /** * Taxizone matrix of the selected hour. * @type {Array.&lt;number[]&gt;} */ zoneMatrix = zoneT[time1]; zones = null; trips = null; /** * Connector dataset for AnyMap. * @see {@link https://docs.anychart.com/7.14.3/Maps/Connector_Maps} * @type {anychart.data.Set} */ connectorData = null; /** * Dataset for AnyMap. * @see {@link https://api.anychart.com/7.14.3/anychart.data.Set} * @type {anychart.data.Set} */ dataSet = anychart.data.set(zoneMatrix); /** * The point that represents a taxizone, corresponding to the clicked path on Chord Diagram. * @type {anychart.core.SeriesPoint} * @see {@link https://api.anychart.com/7.14.3/anychart.core.SeriesPoint} */ pointClickedViaPath = null; lastLayout = null; chordLegendColor = []; } $(function () { initGlobalVariables(); initChordDiagram(); renderMap(); formatJSON(); initSliders(); $('[data-toggle=&quot;popover&quot;]').popover({ trigger: 'manual' }); $('#hourSlider').popover('show'); $('#zoneSlider').popover('show'); $('#btn_pause').click(function (e) { e.preventDefault(); toggleAnimation(false); }); $(&quot;#histogramZone, #histogramHour&quot;).change(function () { generateHistogram(); }); chordAnimation(); }); × Search results Close "},"mapDiagram.js.html":{"id":"mapDiagram.js.html","title":"Source: mapDiagram.js","body":" Smart City Vis Home ChordDiagramHistogramInitialisationMapView Source: mapDiagram.js /** * @author Qiru Wang 689404@swansea.ac.uk * * @module MapView */ $(window).resize(function () { $(&quot;#anymap&quot;).css(&quot;height&quot;, $(&quot;#anymap&quot;).css(&quot;width&quot;)); }); /** * Render a Choropleth map as base series, add Marker series on top of the base series. */ function renderMap() { $('#anymap').empty(); map = anychart.map(); /** Create a AnyMap base map */ map.unboundRegions() .enabled(true) .fill('#E1E1E1') .stroke('#D2D2D2'); /** Map geojson data for drawing taxizone contours */ map.geoData('anychart.maps.taxizone'); /** IMPORTANT!!! map ID field to geojson ID field */ map.geoIdField(&quot;LocationID&quot;); var tempSeries = map.choropleth(connectorBase); tempSeries.id('helper'); tempSeries.enabled(false); tempSeries.legendItem().enabled(false); /** Map data attributes. * @type {anychart.data.Mapping} * @see {@link https://api.anychart.com/7.14.3/anychart.data.Set#mapAs} */ var markerSeries = dataSet.mapAs(null, { name: 'name', id: 'id', size: 'Pickup' }); createDotSeries('0 - 200', markerSeries.filter('size', filterMarkerRange(0, 200)), '#80deea'); createDotSeries('200 - 400', markerSeries.filter('size', filterMarkerRange(200, 400)), '#26c6da'); createDotSeries('400 - 600', markerSeries.filter('size', filterMarkerRange(400, 600)), '#00acc1'); createDotSeries('600 - 800', markerSeries.filter('size', filterMarkerRange(600, 800)), '#0097a7'); createDotSeries('800 - 1,000', markerSeries.filter('size', filterMarkerRange(800, 1000)), '#00838f'); createDotSeries('More than 1,000', markerSeries.filter('size', filterMarkerRange(1000)), '#006064'); /** Enable map legend */ map.legend().enabled(false); /** * Create zoom controllers for the map. * @type {anychart.ui.Zoom} * @see {@link https://api.anychart.com/7.14.3/anychart.ui#zoom} */ var zoomController = anychart.ui.zoom(); zoomController.render(map); /** Disable context menu */ map.contextMenu(false); /** Set map inteactions */ //var interactivity = map.interactivity(); //interactivity.zoomOnMouseWheel(false); //interactivity.zoomOnDoubleClick(false); /** Initiates the drawing into the div with id anymap */ map.container('anymap').draw(); $(&quot;#anymap&quot;).css(&quot;height&quot;, $(&quot;#anymap&quot;).css(&quot;width&quot;)); }; /** * Create a marker series. * * @param {string} name - Name of the marker series. * @param {any} data - Data of the marker series. * @param {string} color - Color of the marker series. * @see {@link https://api.anychart.com/7.14.3/anychart.charts.Map#marker} */ function createDotSeries(name, data, color) { /** Set marker series. * @see {@link https://api.anychart.com/7.14.3/anychart.charts.Map#marker} * @type {anychart.core.map.series.Marker} */ var series = map.marker(data).name(name); series.legendItem({ iconType: &quot;circle&quot;, iconFill: color, iconStroke: '2 #E1E1E1' }); /** Set Tooltip for series */ series.tooltip() .useHtml(true) .padding([8, 13, 10, 13]) .title(false) .separator(false) .fontSize(14) .format(function () { return '&lt;span&gt;' + this.getData('name') + '&lt;/span&gt;&lt;br /&gt;' + '&lt;span style=&quot;font-size: 12px; color: #E1E1E1&quot;&gt;Trips: ' + parseInt(this.getData('size')).toLocaleString() + '&lt;/span&gt;'; }); /** Set styles for marker */ series.selectionMode(&quot;none&quot;) .stroke('2 #757575') .hoverStroke('3 #616161') .fill(color) .size(5) .labels(false) .hoverFill('#e74c3c') .hoverSize(8) .selectType('star7') .selectFill('#e74c3c') .selectSize(10) .type('circle'); series.id(color); series.listen(&quot;pointClick&quot;, function (e) { if (pointClickedViaPath != null) pointClickedViaPath.selected(false); pointClickedViaPath = e.point; pointClickedViaPath.selected(true); removeMapSeries('connector'); map.zoomToFeature(pointClickedViaPath.get(&quot;id&quot;)); toggleAnimation(true); }); }; /** * Filter function to bind data to variables only within the range. * @param {number} start - The start range value. * @param {number} end - The end range value. * @returns {number} - The filtered result. */ function filterMarkerRange(start, end) { if (end) return function (fieldVal) { return start &lt;= fieldVal &amp;&amp; fieldVal &lt; end; }; else return function (fieldVal) { return start &lt;= fieldVal; }; } /** * Generate a Connector coordinate from point A to point B * @param {anychart.core.SeriesPoint} pointA - Point A. * @param {anychart.core.SeriesPoint} pointB - Point B. * @see {@link https://api.anychart.com/7.14.3/anychart.core.SeriesPoint} * @returns {string} - A Connector coordinate in JSON. */ function getConnector(pointA, pointB) { /** get the helper series */ var series = map.getSeries('helper'); /** find regions with proper ids */ var pointIndex1 = series.data().find(&quot;id&quot;, pointA); var pointIndex2 = series.data().find(&quot;id&quot;, pointB); /** get the bounds of the first region */ var point1 = series.getPoint(pointIndex1); var bounds1 = point1.getFeatureBounds(); /** get the bounds of the second region */ var point2 = series.getPoint(pointIndex2); var bounds2 = point2.getFeatureBounds(); /** transformers pixel coordinates to latitude and longitude */ var latLong1 = map.inverseTransform(bounds1.left + bounds1.width / 2, bounds1.top + bounds1.height / 2); var latLong2 = map.inverseTransform(bounds2.left + bounds2.width / 2, bounds2.top + bounds2.height / 2); /** return an array to be used in connector data setv */ return [parseFloat((latLong1.lat).toFixed(7)), parseFloat((latLong1.long).toFixed(7)), parseFloat((latLong2.lat).toFixed(7)), parseFloat((latLong2.long).toFixed(7))]; } /** * Highlight the corresponding marker of the selected zoom on the map. * * @param {string} zone - The zone that should be highlighted. */ function highlightPoint(zone) { if (pointClickedViaPath != null) if (pointClickedViaPath.get('id') != zone.id) pointClickedViaPath.selected(false); var pickup = zone.Pickup; var seriesId; if (pickup &lt; 200) seriesId = '#80deea'; else if (pickup &lt; 400) seriesId = '#26c6da'; else if (pickup &lt; 600) seriesId = '#00acc1'; else if (pickup &lt; 800) seriesId = '#0097a7'; else if (pickup &lt; 1000) seriesId = '#00838f'; else seriesId = '#006064'; var targetSeries = map.getSeries(seriesId); var pointIndex = targetSeries.data().find(&quot;id&quot;, zone.id); if (pointClickedViaPath != null) { if (pointClickedViaPath.get('id') != zone.id) { pointClickedViaPath = targetSeries.getPoint(pointIndex); pointClickedViaPath.selected(true); map.zoomToFeature(zone.id); } } else { pointClickedViaPath = targetSeries.getPoint(pointIndex); pointClickedViaPath.selected(true); map.zoomToFeature(zone.id); } } /** * Add a Connector series to the base map. * * @param {string} connectorData - The JSON data to be added to the base map as a Connector series. */ function addConnectorSeries(connectorData) { /** add connector series */ removeMapSeries('connector'); var connectorSeries = map.connector(connectorData); connectorSeries.id('connector'); connectorSeries.tooltip().format(&quot;{%from} - {%to}&quot;); connectorSeries.legendItem().enabled(false); connectorSeries.listen(&quot;pointClick&quot;, function (e) { toggleAnimation(true); }); } /** * Remove a map series with its ID. * * @param {string} seriesId - The ID of targeted series. */ function removeMapSeries(seriesId) { if (map.getSeries(seriesId) != null) map.removeSeries(seriesId); } × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Smart City Vis Home ChordDiagramHistogramInitialisationMapView Modules × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Smart City Vis Home ChordDiagramHistogramInitialisationMapView Smart City VisualisationInteractive Data Visualisation for New York Taxi Operational Data Developed by Qiru Wang and submitted to Swansea University in partial fulﬁlment for the Degree of Master of Science. Supervised by Dr. Robert S. Laramee in Swansea University. Declaration This work has not previously been accepted in substance for any degree and is not being currently submitted for any degree. This dissertation is being submitted in partial fulﬁlment of the requirements for the degree of a MSc in Computer Science. This dissertation is the result of my own independent work/investigation, except where otherwise stated. Other sources are acknowledged by giving explicit references. A bibliography is appended. I hereby give consent for my dissertation to be available for photocopying and for inter-library loan, and for the title and summary to be made available to outside organisations. Data SourceNYC Taxi and Limousine Commission (TLC) Tools Used IDE Visual Studio Code Visual Studio 2017 Eclipse Third party library jQuery Bootsrap modernizr D3.js AnyChart noUiSlider wNumb pro4j Font Awesome Project management GitHub Taiga Database MySQL Documentation JSDoc DocStrap The above tools used are either open source, free to use or free for educational use. × Search results Close "},"module-ChordDiagram.html":{"id":"module-ChordDiagram.html","title":"Module: ChordDiagram","body":" Smart City Vis Home ChordDiagramHistogramInitialisationMapView Module: ChordDiagram Author: Qiru Wang 689404@swansea.ac.uk Source: chordDiagram.js, line 1 Methods &lt;inner&gt; animationSetData() Update variables zoneMatrix and zoneMatrix, and HTML element 'Hour of the day' to the corresponding hour animated. Source: chordDiagram.js, line 28 &lt;inner&gt; chordAnimation() Start the animation for Chord Diagram. Source: chordDiagram.js, line 11 &lt;inner&gt; formatJSON() Trigger all necessary functions when data is changed. E.g. Re-render Chord Diagram, Map Diagram and Histogram.Also update the visibility of some HTML elements. Source: chordDiagram.js, line 123 &lt;inner&gt; generateChordColorLegend() Generate a legend for Chord Diagram based on the color map used. Source: chordDiagram.js, line 101 &lt;inner&gt; generateRainBowColorMap(trips, totalTrips) Generate a rainbow color map based on the ratio of trips and the total trip count. Parameters: Name Type Description trips number Trip count of one zone as the dividend. totalTrips number Total trip count of all zones as the divisor. Source: chordDiagram.js, line 91 Returns: A rgb color. &lt;inner&gt; getDefaultLayout() Sort the Chord Diagram. Source: chordDiagram.js, line 62 See: https://github.com/d3/d3-3.x-api-reference/blob/master/Chord-Layout.md#chord Returns: The sorted D3 Chord Diagram layout. Type d3.layout &lt;inner&gt; getTripCount(data) Calculate the given trip count. Parameters: Name Type Description data string The input trip count data in JSON. Source: chordDiagram.js, line 75 Returns: The total trip count. Type number &lt;inner&gt; initChordDiagram() Initialise a Chord Diagram. Source: chordDiagram.js, line 207 &lt;inner&gt; spliceMatrix(matrix) Splice the input array based on the zones selected. Parameters: Name Type Description matrix Array.&lt;number&gt; | Array.&lt;string&gt; The input array with all zones. Source: chordDiagram.js, line 183 Returns: The spliced array with the selected zones only. Type Array.&lt;number&gt; | Array.&lt;string&gt; &lt;inner&gt; spliceSubMatrix(matrix) Splice the input nested array based on the zones selected, for trip count matrix. Parameters: Name Type Description matrix Array.&lt;number&gt; Source: chordDiagram.js, line 196 Returns: The spliced array with the selected zones only. Type Array.&lt;number&gt; &lt;inner&gt; toggleAnimation(pausing) Toggle the animation state based on the input boolean value. Parameters: Name Type Description pausing boolean The input boolean value. Source: chordDiagram.js, line 41 &lt;inner&gt; toggleNoMatchMessage(toggle) Toggle the display of 'No Match' message, visulisations and controls. Parameters: Name Type Description toggle boolean If True: displays the message. Source: chordDiagram.js, line 164 &lt;inner&gt; updateChordDiagram(matrix) Update the chords for Chord Diagram. Add event listeners, transition effects and many minor tweaks to Chord Diagram. Parameters: Name Type Description matrix Array.&lt;Array.&lt;number&gt;&gt; The input data matrix of trips Source: chordDiagram.js, line 270 × Search results Close "},"module-Histogram.html":{"id":"module-Histogram.html","title":"Module: Histogram","body":" Smart City Vis Home ChordDiagramHistogramInitialisationMapView Module: Histogram Author: Qiru Wang 689404@swansea.ac.uk Source: histogram.js, line 1 Methods &lt;inner&gt; generateHistogram() Start generating histogram. Source: histogram.js, line 11 &lt;inner&gt; generateHistogramDataHour() Generate data for Hour Histogram. Source: histogram.js, line 23 &lt;inner&gt; generateHistogramDataZone() Generate data for Zone Histogram. Source: histogram.js, line 45 &lt;inner&gt; renderHistogram(input, type) Parameters: Name Type Description input Array.&lt;Array.&lt;any&gt;&gt; The input data for histogram. type string Type of the histogram generate, either Zone or Hour. Source: histogram.js, line 61 × Search results Close "},"module-Initialisation.html":{"id":"module-Initialisation.html","title":"Module: Initialisation","body":" Smart City Vis Home ChordDiagramHistogramInitialisationMapView Module: Initialisation Author: Qiru Wang 689404@swansea.ac.uk Source: init.js, line 1 Members &lt;inner&gt; connectorData :anychart.data.Set Connector dataset for AnyMap. Type: anychart.data.Set Source: init.js, line 130 See: https://docs.anychart.com/7.14.3/Maps/Connector_Maps &lt;inner&gt; dataSet :anychart.data.Set Dataset for AnyMap. Type: anychart.data.Set Source: init.js, line 137 See: https://api.anychart.com/7.14.3/anychart.data.Set &lt;inner&gt; hourSlider :noUiSlider A noUiSlider for hours of the day. Type: noUiSlider Source: init.js, line 105 See: https://refreshless.com/nouislider/ &lt;inner&gt; pointClickedViaPath :anychart.core.SeriesPoint The point that represents a taxizone, corresponding to the clicked path on Chord Diagram. Type: anychart.core.SeriesPoint Source: init.js, line 144 See: https://api.anychart.com/7.14.3/anychart.core.SeriesPoint &lt;inner&gt; time1 :number Starting index of hours selected. Type: number Source: init.js, line 85 &lt;inner&gt; time2 :number Starting index of hours selected. Type: number Source: init.js, line 91 &lt;inner&gt; totalZoneNum :number Total number of taxizones. Type: number Source: init.js, line 67 &lt;inner&gt; tripMatrix :Array.&lt;Array.&lt;number&gt;&gt; Trip count matrix of the selected hour. Type: Array.&lt;Array.&lt;number&gt;&gt; Source: init.js, line 113 &lt;inner&gt; zone1 :number Starting index of taxizones selected. Type: number Source: init.js, line 73 &lt;inner&gt; zone2 :number Ending index of taxizones selected. Type: number Source: init.js, line 79 &lt;inner&gt; zoneMatrix :Array.&lt;Array.&lt;number&gt;&gt; Taxizone matrix of the selected hour. Type: Array.&lt;Array.&lt;number&gt;&gt; Source: init.js, line 119 &lt;inner&gt; zoneSlider :noUiSlider A noUiSlider for taxizones. Type: noUiSlider Source: init.js, line 98 See: https://refreshless.com/nouislider/ Methods &lt;inner&gt; initGlobalVariables() Initialise global variables needed for the application. Source: init.js, line 60 &lt;inner&gt; initSliders() Initialise a noUiSlider for zones and hours. Source: init.js, line 11 See: https://refreshless.com/nouislider/ × Search results Close "},"module-MapView.html":{"id":"module-MapView.html","title":"Module: MapView","body":" Smart City Vis Home ChordDiagramHistogramInitialisationMapView Module: MapView Author: Qiru Wang 689404@swansea.ac.uk Source: mapDiagram.js, line 1 Methods &lt;inner&gt; addConnectorSeries(connectorData) Add a Connector series to the base map. Parameters: Name Type Description connectorData string The JSON data to be added to the base map as a Connector series. Source: mapDiagram.js, line 236 &lt;inner&gt; createDotSeries(name, data, color) Create a marker series. Parameters: Name Type Description name string Name of the marker series. data any Data of the marker series. color string Color of the marker series. Source: mapDiagram.js, line 88 See: https://api.anychart.com/7.14.3/anychart.charts.Map#marker &lt;inner&gt; filterMarkerRange(start, end) Filter function to bind data to variables only within the range. Parameters: Name Type Description start number The start range value. end number The end range value. Source: mapDiagram.js, line 147 Returns: The filtered result. Type number &lt;inner&gt; getConnector(pointA, pointB) Generate a Connector coordinate from point A to point B Parameters: Name Type Description pointA anychart.core.SeriesPoint Point A. pointB anychart.core.SeriesPoint Point B. Source: mapDiagram.js, line 165 See: https://api.anychart.com/7.14.3/anychart.core.SeriesPoint Returns: A Connector coordinate in JSON. Type string &lt;inner&gt; highlightPoint(zone) Highlight the corresponding marker of the selected zoom on the map. Parameters: Name Type Description zone string The zone that should be highlighted. Source: mapDiagram.js, line 193 &lt;inner&gt; removeMapSeries(seriesId) Remove a map series with its ID. Parameters: Name Type Description seriesId string The ID of targeted series. Source: mapDiagram.js, line 254 &lt;inner&gt; renderMap() Render a Choropleth map as base series, add Marker series on top of the base series. Source: mapDiagram.js, line 14 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
